<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="有碰到STL类型的题，就看了下关于STL的视频，粗略学习了下C++以及STL的用法...
以前从没用过C++也没看过和C++相关的知识，所以很多地方还是保持的C代码的风格..很多时候scanf和printf都改不过来...
但是用STL真的..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://ccccj.github.io/media/css/bootstrap.min.css">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/styles/default.min.css">
              
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>
    <link rel="stylesheet" href="https://ccccj.github.io/media/css/live2d.css">
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>
    <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
    <link rel="stylesheet" href="https://ccccj.github.io/media/css/bootstrap.min.css">
    <title>Amon's Homepage</title>
</head>

<body>
    <!-- 响应式布局，针对PC端内容显示 -->
    <div id="content">
        <div class="nav-large">
            <div class="row">
                <div class="side"><html>

<head>
    <link rel="stylesheet" href="https://ccccj.github.io/styles/main.css">
    <meta name="description" content="温故而知新" />
    <title>Document</title>
</head>
<style>
</style>

<body>
    <div id=side>
        <div class="avatar-border">
            <img src="https://ccccj.github.io/images/avatar.png?v=1621778840222" class="avatar">
        </div>
        <div class="sitename">Amon&#39;s Homepage</div>
        <span class="describtion" data-text='["温故而知新"]'>&nbsp;</span>
        
        <div class="search">
            <!-- <input type="text" class="search-input" placeholder="标题搜索(●'◡'●)" /> -->
            <input type="text" class="search-input" placeholder="标题搜索 ⚆_⚆ つ♡">
            <div class="search-results"></div>
        </div>
        
    <div class="share-button">
        <span>社交按钮</span>
        
        <a href="https://github.com/ccccj" target="_blank"><i><img class="icon"
                    src="https://ccccj.github.io/media/images/github.png" alt=""></i></a>
        
        
        <a onclick="showqq()"><i><img class="icon" src="https://ccccj.github.io/media/images/QQ.png" alt=""></i></a>
        
        
        
        
        
    </div>
    <div id="qq" style="display:none">839808679</div>
    
    
    <div class="mchocie describtion">
        <a href="/" class="menubutton">
            home
        </a>
    </div>
    
    
    
    <div class="mchocie describtion">
        <a href="/archives" class="menubutton">
            archives
        </a>
    </div>
    
    
    
    <div class="mchocie describtion">
        <a href="https://github.com/ccccj" class="menubutton">
            github
        </a>
    </div>
    
    
    
    <div class="mchocie describtion">
        <a href="https://blog.csdn.net/qq_40873884" class="menubutton">
            CSDN
        </a>
    </div>
    
    
    
        <div class="mchocie describtion">
            <a href="https://ccccj.github.io/friends" class="menubutton">友人帐</a>
        </div>
    
    <hr>
    <div id="footinfo">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | Theme: <a href="https://github.com/850552586/gridea-theme-fog">Fog</a></div>
    <div id="sitegotimeDate">载入天数...</div>
    <div id="sitegotimes">载入时分秒...</div>
    <div id="cussitetime" style="display:none">02/02/2017</div>
    </div>
</body>

</html>
<script src="https://ccccj.github.io/media/js/wordshow.js"></script>
<script>
    //----------------------站点运行时间
    var now = new Date();

    function createtime() {
        var sitegotime = document.getElementById("cussitetime").innerHTML + " 00:00:00";
        var grt = new Date(sitegotime); //此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("sitegotimeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
        document.getElementById("sitegotimes").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);

    //-------------------------------------------------搜索
    // 获取搜索框、搜索按钮、清空搜索、结果输出对应的元素
    var searchInput = document.querySelector('.search-input');
    var searchResults = document.querySelector('.search-results');

    // 申明保存文章的标题、链接、内容的数组变量
    var searchValue = '',
        arrItems = [],
        arrLinks = [],
        arrTitles = [],
        arrResults = [],
        indexItem = [],
        itemLength = 0;
    var tmpDiv = document.createElement('div');
    tmpDiv.className = 'result-item';

    // ajax 的兼容写法
    var xhr = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTTP');
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && xhr.status == 200) {
            xml = xhr.responseXML;
            arrItems = xml.getElementsByTagName('entry');
            itemLength = arrItems.length;
            console.log(arrItems);
            // 遍历并保存所有文章对应的标题、链接、内容到对应的数组中
            // 同时过滤掉 HTML 标签
            for (i = 0; i < itemLength; i++) {
                var link = arrItems[i].getElementsByTagName('link')[0];
                arrLinks[i] = link.getAttribute("href");
                arrTitles[i] = arrItems[i].getElementsByTagName('title')[0].
                childNodes[0].nodeValue.replace(/<.*?>/g, '');
            }
        }
    }

    // 开始获取根目录下 feed.xml 文件内的数据
    xhr.open('get', '/atom.xml', true);
    xhr.send();



    // 输入框内容变化后就开始匹配，可以不用点按钮
    // 经测试，onkeydown, onchange 等方法效果不太理想，
    // 存在输入延迟等问题，最后发现触发 input 事件最理想，
    // 并且可以处理中文输入法拼写的变化
    searchInput.oninput = function () {
        setTimeout(searchConfirm, 0);
    }
    searchInput.onfocus = function () {
        searchResults.style.display = 'block';
    }

    function searchConfirm() {
        if (searchInput.value == '') {
            searchResults.style.display = 'none';
        } else if (searchInput.value.search(/^\s+$/) >= 0) {
            // 检测输入值全是空白的情况
            searchInit();
            var itemDiv = tmpDiv.cloneNode(true);
            itemDiv.innerText = '请输入有效内容...';
            searchResults.appendChild(itemDiv);
        } else {
            // 合法输入值的情况
            searchInit();
            searchValue = searchInput.value;
            // 在标题、内容中查找
            searchMatching(arrTitles, searchValue);
        }
    }

    // 每次搜索完成后的初始化
    function searchInit() {
        arrResults = [];
        indexItem = [];
        searchResults.innerHTML = '';
        searchResults.style.display = 'block';
    }

    function searchMatching(arr1, input) {
        // 忽略输入大小写
        input = new RegExp(input, 'i');
        // 在所有文章标题、内容中匹配查询值
        for (i = 0; i < itemLength; i++) {
            if (arr1[i].search(input) !== -1) {
                var arr = arr1;
                indexItem.push(i); // 保存匹配值的索引
                var indexContent = arr[i].search(input);
                // 此时 input 为 RegExp 格式 /input/i，转换为原 input 字符串长度
                var l = input.toString().length - 3;
                var step = 10;

                // 将匹配到内容的地方进行黄色标记，并包括周围一定数量的文本
                arrResults.push(arr[i].slice(indexContent - step, indexContent));
            }
        }

        // 输出总共匹配到的数目
        var totalDiv = tmpDiv.cloneNode(true);
        totalDiv.innerHTML = '<b>总匹配：' + indexItem.length + ' 项<hr></b>';
        searchResults.appendChild(totalDiv);

        // 未匹配到内容的情况
        if (indexItem.length == 0) {
            var itemDiv = tmpDiv.cloneNode(true);
            itemDiv.innerText = '未匹配到内容...';
            searchResults.appendChild(itemDiv);
        }

        // 将所有匹配内容进行组合
        for (i = 0; i < arrResults.length; i++) {
            var itemDiv = tmpDiv.cloneNode(true);
            itemDiv.innerHTML = '<b>[' + arrTitles[indexItem[i]] +
                ']</b><p>' + arrResults[i] + "</p><hr />";
            itemDiv.setAttribute('onclick', 'changeHref(arrLinks[indexItem[' + i + ']])');
            searchResults.appendChild(itemDiv);
        }
    }

    function changeHref(href) {
        location.href = href;
    }

    function showqq() {
        var qq = document.getElementById("qq").innerHTML;
        if (qq != '')
            alert("博主的QQ联系方式为：" + qq);
        else
            alert("博主暂未设置QQ联系方式");
    }
</script></div>
                <div id="tab1" class="tab">
                    <div class="bars">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                    <div class="close"></div>
                </div>
                <div id="main" class="col-xs-12 col-sm-7">
                    <link rel="stylesheet" href="https://ccccj.github.io/media/css/font-awesome.css">
<style>

</style>

<body>
    <div class="allcontent">
        <div class="postshow">
            
            <div class="postdetailimg" style="width:100%;overflow: hidden;display: none">
                <img src="https://ccccj.github.io/post-images/acm-stl-biao-zhun-ku-rong-qi-de-ying-yong-vectorqueuelistmap.png" class="postimage" style="cursor:auto">
            </div>
            <div class="postinfo">
                <div class="postdate"><i class="fa fa-calendar"></i>2017-11-04</div>
                <div class="poststatus postdate"><i class="fa fa-clock-o"></i> 20 min read</div>
                <div class="posttag">
                    
                </div>
            </div>
            
            <div id="texttitle" style="text-align: center">
                <h2>ACM: STL标准库容器的应用（vector、queue、list、map）</h2>
            </div>
            <div class="text ">
                <p>有碰到STL类型的题，就看了下关于STL的视频，粗略学习了下C++以及STL的用法...<br>
以前从没用过C++也没看过和C++相关的知识，所以很多地方还是保持的C代码的风格..很多时候scanf和printf都改不过来...<br>
但是用STL真的好方便啊...而且完全不会出错..用过以后再也不想写C了...<br>
顺便再推荐一个网站http://www.cplusplus.com/reference/<br>
查询各种函数超级超级方便。</p>
<p>四道原题，分别是vector、queue、list、map的应用。</p>
<p>https://vjudge.net/contest/208769#problem/B<br>
第一题用的vector。</p>
<p>https://vjudge.net/contest/208769#problem/E<br>
第二题用的vector和queue，本来想用list，后来感觉用queue更方便...</p>
<p>https://vjudge.net/contest/208769#problem/I<br>
第三题用的list，但是我觉得更好的方法不是用STL做...</p>
<p>https://vjudge.net/contest/208769#problem/G<br>
第四题用的map，完全不用处理...只需要输入、构造好、再输出就行了...</p>
<ul>
<li>第一题</li>
</ul>
<h4 id="the-blocks-problem">The Blocks Problem</h4>
<p>Many areas of Computer Science use simple, abstract domains for both analytical and empirical studies. For example, an early AI study of planning and robotics (STRIPS) used a block world in which a robot arm performed tasks involving the manipulation of blocks.<br>
In this problem you will model a simple block world under certain rules and constraints. Rather than determine how to achieve a speci ed state, you will “program” a robotic arm to respond to a limited set of commands.<br>
The problem is to parse a series of commands that instruct a robot arm in how to manipulate blocks that lie on a  at table. Initially there are n blocks on the table (numbered from 0 to n − 1) with block bi adjacent to block bi+1 for all 0 ≤ i &lt; n − 1 as shown in the diagram below:<br>
Initial Blocks World<br>
The valid commands for the robot arm that manipulates blocks are:<br>
• move a onto b<br>
where a and b are block numbers, puts block a onto block b after returning any blocks that are<br>
stacked on top of blocks a and b to their initial positions.<br>
• move a over b<br>
where a and b are block numbers, puts block a onto the top of the stack containing block b, after returning any blocks that are stacked on top of block a to their initial positions.<br>
• pile a onto b<br>
where a and b are block numbers, moves the pile of blocks consisting of block a, and any blocks that are stacked above block a, onto block b. All blocks on top of block b are moved to their initial positions prior to the pile taking place. The blocks stacked above block a retain their order when moved.<br>
• pile a over b<br>
where a and b are block numbers, puts the pile of blocks consisting of block a, and any blocks that are stacked above block a, onto the top of the stack containing block b. The blocks stacked above block a retain their original order when moved.<br>
• quit<br>
terminates manipulations in the block world.<br>
Any command in which a = b or in which a and b are in the same stack of blocks is an illegal command. All illegal commands should be ignored and should have no a ect on the con guration of blocks.</p>
<p>Input</p>
<p>The input begins with an integer n on a line by itself representing the number of blocks in the block world. You may assume that 0 &lt; n &lt; 25.<br>
The number of blocks is followed by a sequence of block commands, one command per line. Your program should process all commands until the quit command is encountered.<br>
You may assume that all commands will be of the form speci ed above. There will be no syntactically incorrect commands.</p>
<p>Output</p>
<p>The output should consist of the  nal state of the blocks world. Each original block position numbered i (0 ≤ i &lt; n where n is the number of blocks) should appear followed immediately by a colon. If there is at least a block on it, the colon must be followed by one space, followed by a list of blocks that appear stacked in that position with each block number separated from other block numbers by a space. Don’t put any trailing spaces on a line.<br>
There should be one line of output for each block position (i.e., n lines of output where n is the integer on the  rst line of input).</p>
<p>Sample Input</p>
<p>10<br>
move 9 onto 1<br>
move 8 over 1<br>
move 7 over 1<br>
move 6 over 1<br>
pile 8 over 6<br>
pile 8 over 5<br>
move 2 over 1<br>
move 4 over 9<br>
quit</p>
<p>Sample Output</p>
<p>0: 0<br>
1: 1 9 2 4<br>
2:<br>
3: 3<br>
4:<br>
5: 5 8 7 6<br>
6:<br>
7:<br>
8:<br>
9:</p>
<p>题目超级超级超级难读懂...看了好几遍没看懂就有道翻译了...有道看了几遍还是看不懂就百度了...主要读懂四个模拟操作就行。</p>
<ul>
<li>move onto  将a、b上的积木还原、a放到b上</li>
<li>move over  将a上的积木还原，a放到b顶端</li>
<li>pile onto  将b上积木还原，a及a上积木放到b上</li>
<li>pile over  a及a上积木放到b顶端</li>
</ul>
<p>简单讲下思路，主要是用数组，数组里面是vector（可动态增长）；<br>
主要函数有：<br>
1.查看行和高度；<br>
2.将某个块.求出高度后,上面的数还原；<br>
3.移动：移动的函数可以只有一个，若a移动到b，发现，可以统一概括为移动b的顶部；<br>
然后其他的思路什么的就很简单了...不说了不说了..</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; pile[25]; 

void search(int &amp;row, int &amp;height, int a) // 查看第几行和高度
{
    for (int i = 0; i &lt; 25; i++) {
        for (int j = 0; j &lt; pile[i].size(); j++) {
            if (pile[i][j] == a) {
                row = i;
                height = j;
                return;
            }
        }
    }
}

void reset(int a, int row, int height) // 还原某一个块上的积木
{
    for (unsigned long i = pile[row].size() - 1; i &gt; height; i--) {
        int k = pile[row][i];
        pile[row].pop_back();
        pile[k].push_back(k);
    }
}

void block_move(int row1, int row2, int height_a) //移动a到b上，或b顶端
{
    for (int i = height_a; i &lt; pile[row1].size(); i++) {
        pile[row2].push_back(pile[row1][i]);
    }
    pile[row1].resize( height_a );
}

int main(int argc, const char * argv[]) {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for ( int i = 0; i &lt; n; i++) {
        pile[i].push_back(i);
    }
    vector&lt;int&gt; ::iterator it;
    string command1;
    string command2;
    while (cin &gt;&gt; command1 &amp;&amp; command1 != &quot;quit&quot; ) {
        int a;
        cin &gt;&gt; a;
        cin &gt;&gt; command2;
        int b;
        cin &gt;&gt; b;
        
        int row1 = 0, row2 = 0, height1 = 0, height2 = 0;
        search(row1, height1, a);
        search(row2, height2, b);
        if (row1 == row2) {
            continue;
        }
        
        if ( command1 == &quot;move&quot; ) {
            if ( command2 == &quot;onto&quot; ) {
                // move onto
                // 将a、b上的积木还原、a放到b上
                reset(a, row1, height1);
                reset(b, row2, height2);
            }
            else {
                // move over
                // 将a上的积木还原，a放到b顶端
                reset(a, row1, height1);
            }
        }
        else {
            if ( command2 == &quot;onto&quot; ) {
                // pile onto
                // 将b上积木还原，a及a上积木放到b上
                reset(b, row2, height2);
            }
            // pile over
            // a及a上积木放到b顶端
        }
        block_move(row1, row2, height1);
    }
    // 啊下面的忽略。。改不掉C
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d:&quot;,i);
        for (int j = 0; j &lt; pile[i].size(); j++) {
            printf(&quot; %d&quot;,pile[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<ul>
<li>第二题</li>
</ul>
<h4 id="team-queue">Team Queue</h4>
<p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>
In a team queue each element belongs to a team. If an element enters the queue, it  rst searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.<br>
Your task is to write a program that simulates such a team queue.</p>
<p>Input</p>
<p>The input  le will contain one or more test cases. Each test case begins with the number of teams t (1 ≤ t ≤ 1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0..999999. A team may consist of up to 1000 elements.<br>
Finally, a list of commands follows. There are three di erent kinds of commands: • ENQUEUE x — enter element x into the team queue<br>
• DEQUEUE — process the  rst element and remove it from the queue • STOP — end of test case<br>
The input will be terminated by a value of 0 for t.<br>
Warning: A test case may contain up to 200000 (two hundred thousand) commands, so the imple- mentation of the team queue should be e cient: both enqueing and dequeuing of an element should only take constant time.</p>
<p>Output</p>
<p>For each test case,  rst print a line saying ‘Scenario #k’, where k is the number of the test case. Then, for each ‘DEQUEUE’ command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p>
<p>Sample Input</p>
<p>2<br>
3 101 102 103<br>
3 201 202 203<br>
ENQUEUE 101<br>
ENQUEUE 201<br>
ENQUEUE 102<br>
ENQUEUE 202<br>
ENQUEUE 103<br>
ENQUEUE 203<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
STOP<br>
2<br>
5 259001 259002 259003 259004 259005<br>
6 260001 260002 260003 260004 260005 260006<br>
ENQUEUE 259001<br>
ENQUEUE 260001<br>
ENQUEUE 259002<br>
ENQUEUE 259003<br>
ENQUEUE 259004<br>
ENQUEUE 259005<br>
DEQUEUE<br>
DEQUEUE<br>
ENQUEUE 260002<br>
ENQUEUE 260003<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
STOP<br>
0</p>
<p>Sample Output</p>
<p>Scenario #1<br>
101<br>
102<br>
103<br>
201 202 203<br>
Scenario #2<br>
259001<br>
259002<br>
259003<br>
259004<br>
259005<br>
260001</p>
<p>这题英文还算好懂..啊现在每次读ACM的题..简直难度max的阅读理解...<br>
大概意思就是，先输入几个team，告诉你每个team的成员有谁，再输入一个入队顺序，根据前面的队员关系，判断新入队的排哪去。只要有一个队员在前面，这个队伍的其他成员就可以无限插队。<br>
所以先将每个队的队员记录下来（1.内容是vector的数组），再将每个队员（2.内容是queue的数组）的顺序记录下来，在将每个队伍的顺序记录下来（3.vector）。第一组记录完不用动，只需要不断地查找即可，第二组不断地改变，因为需要入队出队，用queue最合适（但是想了下list应该也可以），因为只要有队员在最开头，这组成员可以一直插队，但是当这组成员没有在开头了，那就不能插队，用第三组的vector来记录这一队有没有人在开头。</p>
<p>啊啊啊啊讲不清....总之不需要建立一个很长很长的队列，来看入队出队的顺序，要移动的太多了，单独每组team一个queue就可以了。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

void find_row(vector&lt;int&gt; relat[], int num, int t, int &amp;row) // 查找在哪个队
{
    for (int i = 0; i &lt; t; i++) {
        for (int j = 0; j &lt; relat[i].size(); j++) {
            if (relat[i][j] == num) {
                row = i;
                return;
            }
        }
    }
}

int judge(vector&lt;int&gt; order, int n) // 判断
{
    for (int i = 0; i &lt; order.size(); i++) {
        if (order[i] == n) {
            return 1;
        }
    }
    return 0;
}

int main()
{
    int t = 0;
    int Scenario = 0;
    while (~scanf(&quot;%d&quot;, &amp;t) &amp;&amp; t != 0) {
        
        vector&lt;int&gt; relat[1000]; // 存储关系
        queue&lt;int&gt; Queue[1000]; // 存储入队出队顺序
        vector&lt;int&gt; order; // 存储组别是否出队完
        
        int d = 0;
        for (int i = 0; i &lt; t; i++) {
            cin &gt;&gt; d;
            for (int j = 0; j &lt; d; j++) {
                int num;
                cin &gt;&gt; num;
                relat[i].push_back(num);
            }
        }
        string command;
        cin &gt;&gt; command;
        printf(&quot;Scenario #%d\n&quot;,++Scenario);
        while ( command[0] != 'S' ) {
            if (command[0] == 'E') {
                // 入队
                int num;
                cin &gt;&gt; num;
                int row = 0;
                find_row(relat, num, t, row);
                Queue[row].push(num);
                if (judge(order, row) == 0) {
                    order.push_back(row);
                }
            }
            else {
                // 出队
                int row1 = order[0];
                printf(&quot;%d\n&quot;,Queue[row1].front());
                Queue[row1].pop();
                if (Queue[row1].size() == 0) {
                    order.erase(order.begin());
                }
            }
            cin &gt;&gt; command;
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<ul>
<li>第三题</li>
</ul>
<h4 id="士兵队列训练问题">士兵队列训练问题</h4>
<p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。</p>
<p>Input</p>
<p>本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。</p>
<p>Output</p>
<p>共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。</p>
<p>Sample Input<br>
2<br>
20<br>
40</p>
<p>Sample Output<br>
1 7 19<br>
1 19 37</p>
<p>这道题....坑...一开始没理解题的意思，一直以为是小于等于3个人就停止，但是实际上就算小于3个人了这一轮报数也要继续下去。<br>
如果用STL做的话，最好的方法应该是双向链表list（啊不包括map啊什么的...那些我还没看过..）。对链表的访问必须要用迭代器。但是删除元素的时候要注意迭代器会指向被删除元素的下一个元素（一开始不知道，总是运行运行就访问越界了）。<br>
还有list的迭代器是双向迭代器，不是随机访问迭代器，很多操作不能做，比如说给迭代器直接+n或迭代器之间比较大小，所以有些地方的判定要注意。迭代器的每次后移，都要判定到end了没。<br>
话说end()函数，是返回一个指向头结点的迭代器（也就是最后一个结点，list是循环迭代器），所以可以用来判定。<br>
第一次的时候超时间了，因为每次判定人数都是直接用size函数，但是size需要循环，时间复杂度为O(n)，直接自己用一个计数器就不会超时了。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;

using namespace std;

int main()
{
    int N;
    while (~scanf(&quot;%d&quot;, &amp;N)) {
        while (N--) {
            list&lt;int&gt; soldier;
            int num;
            cin &gt;&gt; num;
            for (int i = 0; i &lt; num; i++) {
                soldier.push_back(i+1);
            }
            
            list&lt;int&gt;::iterator it;
            while (num &gt; 3) {
                it = soldier.begin();
                while ( it != soldier.end() ) {
                    it++;
                    if ( it == soldier.end() ) {
                        break;
                    }
                    list&lt;int&gt;::iterator it2;
                    it2 = it;
                    it2++;
                    if (it2 == soldier.end()) {
                        it = soldier.erase(it);
                        num--;
                        break;
                    } // 话说这里...好像删除最后一个结点的时候..不知道迭代器发生了什么...指不到end去了...？？？
                    it = soldier.erase(it);
                    num--;
                }
                it = soldier.begin();
                if (num &lt;= 3) {
                    break;
                }
                while (it != soldier.end() ) {
                    it++;
                    if ( it == soldier.end()) {
                        break;
                    }
                    it++;
                    if ( it == soldier.end()) {
                        break;
                    }
                    list&lt;int&gt;::iterator it2;
                    it2 = it;
                    it2++;
                    if (it2 == soldier.end()) {
                        it = soldier.erase(it);
                        num--;
                        break;
                    }
                    it = soldier.erase(it);
                    num--; 
                }
            }
            it = soldier.begin();
            cout &lt;&lt; *it;
            it++;
            for ( ; it != soldier.end(); it++) {
                cout &lt;&lt; ' ' &lt;&lt; *it ;
            }
            cout &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
<ul>
<li>第四题</li>
</ul>
<h5 id="水果">水果</h5>
<p>夏天来了~~好开心啊,呵呵,好多好多水果<br>
Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.</p>
<p>Input</p>
<p>第一行正整数N(0 &lt; N &lt;= 10)表示有N组测试数据.<br>
每组测试数据的第一行是一个整数M(0 &lt; M &lt;= 100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.</p>
<p>Output</p>
<p>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br>
两组测试数据之间有一个空行.最后一组测试数据之后没有空行.</p>
<p>Sample Input</p>
<p>1<br>
5<br>
apple shandong 3<br>
pineapple guangdong 1<br>
sugarcane guangdong 1<br>
pineapple guangdong 3<br>
pineapple guangdong 1</p>
<p>Sample Output</p>
<p>guangdong<br>
|----pineapple(5)<br>
|----sugarcane(1)<br>
shandong<br>
|----apple(3)</p>
<p>这题用map算是很合适了吧...<br>
先说下map，也是容器的一种.....<br>
好了..本来这里写了一大段，传上去以后发现，消失了！！！消失了！！难受...已经不想写了..图再发一遍吧..</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI0MjIyNjU0NTI4?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
就简单讲下吧..这是个map &lt; string, int &gt; 容器的图，但是这道题有两个关键字，第一关键字为地区，第二关键字为水果名，所以需要两个map容器。如下图：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI0MjIyOTIyODQ3?x-oss-process=image/format,png" alt=" " loading="lazy"><br>
类似于二维数组的构造（数组里面有数组），这是个map当中有map的构造，看图应该就能看懂了。一开始我一直在想，如果两个水果地区都是guangdong，那不是关键字重复了么，还查了好久关键字重复怎么办...后来画了个图就懂了，如果都是广东，在左边一列算是一个关键字，然后在右边再细分。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int N;
    string fruit, place;
    int num;
    scanf(&quot;%d&quot;, &amp;N);
    while (N--) {
        map&lt;string, map&lt;string, int&gt;&gt; myfruit;
        int M;
        cin &gt;&gt; M;
        for ( int i = 0; i &lt; M; i++) {
            cin &gt;&gt; fruit &gt;&gt; place &gt;&gt; num;
            myfruit[place][fruit] += num;
        }
        map&lt;string, map&lt;string, int&gt;&gt;::iterator it;
        map&lt;string, int&gt; :: iterator it2;
        for (it = myfruit.begin(); it != myfruit.end(); it++) {
            cout &lt;&lt; it-&gt;first &lt;&lt; endl;
            for ( it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) {
                cout &lt;&lt; &quot;   |----&quot; &lt;&lt; it2-&gt;first &lt;&lt; '(' &lt;&lt; it2-&gt;second &lt;&lt; ')' &lt;&lt; endl;
            }
        }
        if (N &gt; 0)
            cout &lt;&lt; endl;
    }
    return 0;
}

</code></pre>

            </div>
            
            <div class="prev-post">
                上一篇
                <a href="https://ccccj.github.io/xiao-jie-or-c-yu-yan-cao-zuo-fu/">
                    小结 | C语言操作符
                </a>
            </div>
            
            
            <div class="next-post">
                下一篇
                <a href="https://ccccj.github.io/acmlcm-walk/">
                    ACM：LCM Walk
                </a>
            </div>
            
        </div>
    </div>
</body>
<script>
    var t_img; // 定时器
    var isLoad = true; // 控制变量
    isImgLoad(function () {
        // 加载完成
        $('.postdetailimg').css("display", "block");
    });
    // 判断图片加载的函数
    function isImgLoad(callback) {
        // 注意我的图片类名都是cover，因为我只需要处理cover。其它图片可以不管。
        // 查找所有封面图，迭代处理
        $('.postdetailimg').each(function () {
            // 找到为0就将isLoad设为false，并退出each
            if (this.height === 0) {
                isLoad = false;
                return false;
            }
        });
        // 为true，没有发现为0的。加载完毕
        if (isLoad) {
            clearTimeout(t_img); // 清除定时器
            // 回调函数
            callback();
            // 为false，因为找到了没有加载完成的图，将调用定时器递归
        } else {
            isLoad = true;
            t_img = setTimeout(function () {
                isImgLoad(callback); // 递归扫描
            }, 500); // 我这里设置的是500毫秒就扫描一次，可以自己调整
        }
    }
</script>
                    <div name="comment" style="background: white">
                        <div class="commentcontainer">
                            
                            <head>
    <script src='https://ccccj.github.io/media/js/valine.min.js'></script>
    <script src="https://ccccj.github.io/media/js/jquery.min.js"></script>
</head>
<style>
    @media screen and (min-width: 1300px) {
    .v .vbtn.vsubmit {
        border-radius: 0;
        padding: 0;
        color: #fff;
        line-height: 44px;
        width: 100%;
        border: none;
        background: #1abc9c;
    }

    .v .vwrap .vedit .vctrl span.vpreview-btn,
    .v .vwrap .vcontrol .col.col-20,
    .v .vlist .vcard .vhead .vsys {
        display: none;
    }

    .v .vwrap .vmark .valert {
        padding-top: 0px;
    }

    .vtext{
        padding: 0;
    }
}

    @media screen and (max-width: 1300px) {
        .v .vwrap .vmark .valert{
            margin-top:60%;
        }
        .vwrap{
            margin: 15px;
            width: 90%;
        }
        .v .vwrap .vheader .vinput {
            padding: 10px 5px;
        }
        .v .vwrap{
            overflow: auto;
        }
        .v .veditor {
            min-height: 30rem;
            resize: none;
        }

        .v .vinput {
            padding: 10px 15px;
            font-size: 20px;
        }

        .v .vwrap .vedit .vctrl {
            right: 0;
        }

        .v .vempty {
            padding: 1.25em;
            text-align: center;
            color: #999;
            font-size: 25px;
        }

    }
</style>

<body>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: '1',
            appKey: '2',
            notify: true,
            verify: false,
            avatar: 'retro',
            pageSize: 30,
            placeholder: '既然来了，何不畅所欲言呢？',
        })
    </script>
</body>
                            <div class="clear"></div>
                            
                        </div>
                    </div>
                </div>
                <div class="toc-container">
                    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#the-blocks-problem">The Blocks Problem</a></li>
<li><a href="#team-queue">Team Queue</a></li>
<li><a href="#%E5%A3%AB%E5%85%B5%E9%98%9F%E5%88%97%E8%AE%AD%E7%BB%83%E9%97%AE%E9%A2%98">士兵队列训练问题</a>
<ul>
<li><a href="#%E6%B0%B4%E6%9E%9C">水果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                </div>
            </div>
        </div>
        <div id="bg">
        </div>
        <div id="bgurl" style="display:none">/media/images/bgimg.png</div>
    </div>
    <!-- 响应式布局，针对手机端内容显示 -->
    <div class="nav-small">
        <head>

  <!-- 引入Bootstrap核心样式文件 -->
  <link rel="stylesheet" href="https://ccccj.github.io/media/css/bootstrap.min.css">
</head>

<body>
  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container-fluid">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
          data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="#">Amon&#39;s Homepage&nbsp;&nbsp;|</a>
      </div>

      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav">
          
          
          <li>
            <a href="/">
              home
            </a>
          </li>
          
          
          
          <li>
            <a href="/archives">
              archives
            </a>
          </li>
          
          
          
          <li>
            <a href="https://github.com/ccccj">
              github
            </a>
          </li>
          
          
          
          <li>
            <a href="https://blog.csdn.net/qq_40873884">
              CSDN
            </a>
          </li>
          
          
          
          <li><a href="https://ccccj.github.io/friends">友链</a></li>

          
        </ul>
      </div><!-- /.navbar-collapse -->
    </div><!-- /.container-fluid -->
  </nav>


  <!-- 引入jQuery核心js文件 -->
  <script src="http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"></script>
  <!-- 引入BootStrap核心js文件 -->
  <script src="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</body>
        <div style="margin-top:30px"></div>
        <link rel="stylesheet" href="https://ccccj.github.io/media/css/font-awesome.css">
<style>

</style>

<body>
    <div class="allcontent">
        <div class="postshow">
            
            <div class="postdetailimg" style="width:100%;overflow: hidden;display: none">
                <img src="https://ccccj.github.io/post-images/acm-stl-biao-zhun-ku-rong-qi-de-ying-yong-vectorqueuelistmap.png" class="postimage" style="cursor:auto">
            </div>
            <div class="postinfo">
                <div class="postdate"><i class="fa fa-calendar"></i>2017-11-04</div>
                <div class="poststatus postdate"><i class="fa fa-clock-o"></i> 20 min read</div>
                <div class="posttag">
                    
                </div>
            </div>
            
            <div id="texttitle" style="text-align: center">
                <h2>ACM: STL标准库容器的应用（vector、queue、list、map）</h2>
            </div>
            <div class="text ">
                <p>有碰到STL类型的题，就看了下关于STL的视频，粗略学习了下C++以及STL的用法...<br>
以前从没用过C++也没看过和C++相关的知识，所以很多地方还是保持的C代码的风格..很多时候scanf和printf都改不过来...<br>
但是用STL真的好方便啊...而且完全不会出错..用过以后再也不想写C了...<br>
顺便再推荐一个网站http://www.cplusplus.com/reference/<br>
查询各种函数超级超级方便。</p>
<p>四道原题，分别是vector、queue、list、map的应用。</p>
<p>https://vjudge.net/contest/208769#problem/B<br>
第一题用的vector。</p>
<p>https://vjudge.net/contest/208769#problem/E<br>
第二题用的vector和queue，本来想用list，后来感觉用queue更方便...</p>
<p>https://vjudge.net/contest/208769#problem/I<br>
第三题用的list，但是我觉得更好的方法不是用STL做...</p>
<p>https://vjudge.net/contest/208769#problem/G<br>
第四题用的map，完全不用处理...只需要输入、构造好、再输出就行了...</p>
<ul>
<li>第一题</li>
</ul>
<h4 id="the-blocks-problem">The Blocks Problem</h4>
<p>Many areas of Computer Science use simple, abstract domains for both analytical and empirical studies. For example, an early AI study of planning and robotics (STRIPS) used a block world in which a robot arm performed tasks involving the manipulation of blocks.<br>
In this problem you will model a simple block world under certain rules and constraints. Rather than determine how to achieve a speci ed state, you will “program” a robotic arm to respond to a limited set of commands.<br>
The problem is to parse a series of commands that instruct a robot arm in how to manipulate blocks that lie on a  at table. Initially there are n blocks on the table (numbered from 0 to n − 1) with block bi adjacent to block bi+1 for all 0 ≤ i &lt; n − 1 as shown in the diagram below:<br>
Initial Blocks World<br>
The valid commands for the robot arm that manipulates blocks are:<br>
• move a onto b<br>
where a and b are block numbers, puts block a onto block b after returning any blocks that are<br>
stacked on top of blocks a and b to their initial positions.<br>
• move a over b<br>
where a and b are block numbers, puts block a onto the top of the stack containing block b, after returning any blocks that are stacked on top of block a to their initial positions.<br>
• pile a onto b<br>
where a and b are block numbers, moves the pile of blocks consisting of block a, and any blocks that are stacked above block a, onto block b. All blocks on top of block b are moved to their initial positions prior to the pile taking place. The blocks stacked above block a retain their order when moved.<br>
• pile a over b<br>
where a and b are block numbers, puts the pile of blocks consisting of block a, and any blocks that are stacked above block a, onto the top of the stack containing block b. The blocks stacked above block a retain their original order when moved.<br>
• quit<br>
terminates manipulations in the block world.<br>
Any command in which a = b or in which a and b are in the same stack of blocks is an illegal command. All illegal commands should be ignored and should have no a ect on the con guration of blocks.</p>
<p>Input</p>
<p>The input begins with an integer n on a line by itself representing the number of blocks in the block world. You may assume that 0 &lt; n &lt; 25.<br>
The number of blocks is followed by a sequence of block commands, one command per line. Your program should process all commands until the quit command is encountered.<br>
You may assume that all commands will be of the form speci ed above. There will be no syntactically incorrect commands.</p>
<p>Output</p>
<p>The output should consist of the  nal state of the blocks world. Each original block position numbered i (0 ≤ i &lt; n where n is the number of blocks) should appear followed immediately by a colon. If there is at least a block on it, the colon must be followed by one space, followed by a list of blocks that appear stacked in that position with each block number separated from other block numbers by a space. Don’t put any trailing spaces on a line.<br>
There should be one line of output for each block position (i.e., n lines of output where n is the integer on the  rst line of input).</p>
<p>Sample Input</p>
<p>10<br>
move 9 onto 1<br>
move 8 over 1<br>
move 7 over 1<br>
move 6 over 1<br>
pile 8 over 6<br>
pile 8 over 5<br>
move 2 over 1<br>
move 4 over 9<br>
quit</p>
<p>Sample Output</p>
<p>0: 0<br>
1: 1 9 2 4<br>
2:<br>
3: 3<br>
4:<br>
5: 5 8 7 6<br>
6:<br>
7:<br>
8:<br>
9:</p>
<p>题目超级超级超级难读懂...看了好几遍没看懂就有道翻译了...有道看了几遍还是看不懂就百度了...主要读懂四个模拟操作就行。</p>
<ul>
<li>move onto  将a、b上的积木还原、a放到b上</li>
<li>move over  将a上的积木还原，a放到b顶端</li>
<li>pile onto  将b上积木还原，a及a上积木放到b上</li>
<li>pile over  a及a上积木放到b顶端</li>
</ul>
<p>简单讲下思路，主要是用数组，数组里面是vector（可动态增长）；<br>
主要函数有：<br>
1.查看行和高度；<br>
2.将某个块.求出高度后,上面的数还原；<br>
3.移动：移动的函数可以只有一个，若a移动到b，发现，可以统一概括为移动b的顶部；<br>
然后其他的思路什么的就很简单了...不说了不说了..</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; pile[25]; 

void search(int &amp;row, int &amp;height, int a) // 查看第几行和高度
{
    for (int i = 0; i &lt; 25; i++) {
        for (int j = 0; j &lt; pile[i].size(); j++) {
            if (pile[i][j] == a) {
                row = i;
                height = j;
                return;
            }
        }
    }
}

void reset(int a, int row, int height) // 还原某一个块上的积木
{
    for (unsigned long i = pile[row].size() - 1; i &gt; height; i--) {
        int k = pile[row][i];
        pile[row].pop_back();
        pile[k].push_back(k);
    }
}

void block_move(int row1, int row2, int height_a) //移动a到b上，或b顶端
{
    for (int i = height_a; i &lt; pile[row1].size(); i++) {
        pile[row2].push_back(pile[row1][i]);
    }
    pile[row1].resize( height_a );
}

int main(int argc, const char * argv[]) {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for ( int i = 0; i &lt; n; i++) {
        pile[i].push_back(i);
    }
    vector&lt;int&gt; ::iterator it;
    string command1;
    string command2;
    while (cin &gt;&gt; command1 &amp;&amp; command1 != &quot;quit&quot; ) {
        int a;
        cin &gt;&gt; a;
        cin &gt;&gt; command2;
        int b;
        cin &gt;&gt; b;
        
        int row1 = 0, row2 = 0, height1 = 0, height2 = 0;
        search(row1, height1, a);
        search(row2, height2, b);
        if (row1 == row2) {
            continue;
        }
        
        if ( command1 == &quot;move&quot; ) {
            if ( command2 == &quot;onto&quot; ) {
                // move onto
                // 将a、b上的积木还原、a放到b上
                reset(a, row1, height1);
                reset(b, row2, height2);
            }
            else {
                // move over
                // 将a上的积木还原，a放到b顶端
                reset(a, row1, height1);
            }
        }
        else {
            if ( command2 == &quot;onto&quot; ) {
                // pile onto
                // 将b上积木还原，a及a上积木放到b上
                reset(b, row2, height2);
            }
            // pile over
            // a及a上积木放到b顶端
        }
        block_move(row1, row2, height1);
    }
    // 啊下面的忽略。。改不掉C
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d:&quot;,i);
        for (int j = 0; j &lt; pile[i].size(); j++) {
            printf(&quot; %d&quot;,pile[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<ul>
<li>第二题</li>
</ul>
<h4 id="team-queue">Team Queue</h4>
<p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>
In a team queue each element belongs to a team. If an element enters the queue, it  rst searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.<br>
Your task is to write a program that simulates such a team queue.</p>
<p>Input</p>
<p>The input  le will contain one or more test cases. Each test case begins with the number of teams t (1 ≤ t ≤ 1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0..999999. A team may consist of up to 1000 elements.<br>
Finally, a list of commands follows. There are three di erent kinds of commands: • ENQUEUE x — enter element x into the team queue<br>
• DEQUEUE — process the  rst element and remove it from the queue • STOP — end of test case<br>
The input will be terminated by a value of 0 for t.<br>
Warning: A test case may contain up to 200000 (two hundred thousand) commands, so the imple- mentation of the team queue should be e cient: both enqueing and dequeuing of an element should only take constant time.</p>
<p>Output</p>
<p>For each test case,  rst print a line saying ‘Scenario #k’, where k is the number of the test case. Then, for each ‘DEQUEUE’ command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p>
<p>Sample Input</p>
<p>2<br>
3 101 102 103<br>
3 201 202 203<br>
ENQUEUE 101<br>
ENQUEUE 201<br>
ENQUEUE 102<br>
ENQUEUE 202<br>
ENQUEUE 103<br>
ENQUEUE 203<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
STOP<br>
2<br>
5 259001 259002 259003 259004 259005<br>
6 260001 260002 260003 260004 260005 260006<br>
ENQUEUE 259001<br>
ENQUEUE 260001<br>
ENQUEUE 259002<br>
ENQUEUE 259003<br>
ENQUEUE 259004<br>
ENQUEUE 259005<br>
DEQUEUE<br>
DEQUEUE<br>
ENQUEUE 260002<br>
ENQUEUE 260003<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
STOP<br>
0</p>
<p>Sample Output</p>
<p>Scenario #1<br>
101<br>
102<br>
103<br>
201 202 203<br>
Scenario #2<br>
259001<br>
259002<br>
259003<br>
259004<br>
259005<br>
260001</p>
<p>这题英文还算好懂..啊现在每次读ACM的题..简直难度max的阅读理解...<br>
大概意思就是，先输入几个team，告诉你每个team的成员有谁，再输入一个入队顺序，根据前面的队员关系，判断新入队的排哪去。只要有一个队员在前面，这个队伍的其他成员就可以无限插队。<br>
所以先将每个队的队员记录下来（1.内容是vector的数组），再将每个队员（2.内容是queue的数组）的顺序记录下来，在将每个队伍的顺序记录下来（3.vector）。第一组记录完不用动，只需要不断地查找即可，第二组不断地改变，因为需要入队出队，用queue最合适（但是想了下list应该也可以），因为只要有队员在最开头，这组成员可以一直插队，但是当这组成员没有在开头了，那就不能插队，用第三组的vector来记录这一队有没有人在开头。</p>
<p>啊啊啊啊讲不清....总之不需要建立一个很长很长的队列，来看入队出队的顺序，要移动的太多了，单独每组team一个queue就可以了。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

void find_row(vector&lt;int&gt; relat[], int num, int t, int &amp;row) // 查找在哪个队
{
    for (int i = 0; i &lt; t; i++) {
        for (int j = 0; j &lt; relat[i].size(); j++) {
            if (relat[i][j] == num) {
                row = i;
                return;
            }
        }
    }
}

int judge(vector&lt;int&gt; order, int n) // 判断
{
    for (int i = 0; i &lt; order.size(); i++) {
        if (order[i] == n) {
            return 1;
        }
    }
    return 0;
}

int main()
{
    int t = 0;
    int Scenario = 0;
    while (~scanf(&quot;%d&quot;, &amp;t) &amp;&amp; t != 0) {
        
        vector&lt;int&gt; relat[1000]; // 存储关系
        queue&lt;int&gt; Queue[1000]; // 存储入队出队顺序
        vector&lt;int&gt; order; // 存储组别是否出队完
        
        int d = 0;
        for (int i = 0; i &lt; t; i++) {
            cin &gt;&gt; d;
            for (int j = 0; j &lt; d; j++) {
                int num;
                cin &gt;&gt; num;
                relat[i].push_back(num);
            }
        }
        string command;
        cin &gt;&gt; command;
        printf(&quot;Scenario #%d\n&quot;,++Scenario);
        while ( command[0] != 'S' ) {
            if (command[0] == 'E') {
                // 入队
                int num;
                cin &gt;&gt; num;
                int row = 0;
                find_row(relat, num, t, row);
                Queue[row].push(num);
                if (judge(order, row) == 0) {
                    order.push_back(row);
                }
            }
            else {
                // 出队
                int row1 = order[0];
                printf(&quot;%d\n&quot;,Queue[row1].front());
                Queue[row1].pop();
                if (Queue[row1].size() == 0) {
                    order.erase(order.begin());
                }
            }
            cin &gt;&gt; command;
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<ul>
<li>第三题</li>
</ul>
<h4 id="士兵队列训练问题">士兵队列训练问题</h4>
<p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。</p>
<p>Input</p>
<p>本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。</p>
<p>Output</p>
<p>共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。</p>
<p>Sample Input<br>
2<br>
20<br>
40</p>
<p>Sample Output<br>
1 7 19<br>
1 19 37</p>
<p>这道题....坑...一开始没理解题的意思，一直以为是小于等于3个人就停止，但是实际上就算小于3个人了这一轮报数也要继续下去。<br>
如果用STL做的话，最好的方法应该是双向链表list（啊不包括map啊什么的...那些我还没看过..）。对链表的访问必须要用迭代器。但是删除元素的时候要注意迭代器会指向被删除元素的下一个元素（一开始不知道，总是运行运行就访问越界了）。<br>
还有list的迭代器是双向迭代器，不是随机访问迭代器，很多操作不能做，比如说给迭代器直接+n或迭代器之间比较大小，所以有些地方的判定要注意。迭代器的每次后移，都要判定到end了没。<br>
话说end()函数，是返回一个指向头结点的迭代器（也就是最后一个结点，list是循环迭代器），所以可以用来判定。<br>
第一次的时候超时间了，因为每次判定人数都是直接用size函数，但是size需要循环，时间复杂度为O(n)，直接自己用一个计数器就不会超时了。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;

using namespace std;

int main()
{
    int N;
    while (~scanf(&quot;%d&quot;, &amp;N)) {
        while (N--) {
            list&lt;int&gt; soldier;
            int num;
            cin &gt;&gt; num;
            for (int i = 0; i &lt; num; i++) {
                soldier.push_back(i+1);
            }
            
            list&lt;int&gt;::iterator it;
            while (num &gt; 3) {
                it = soldier.begin();
                while ( it != soldier.end() ) {
                    it++;
                    if ( it == soldier.end() ) {
                        break;
                    }
                    list&lt;int&gt;::iterator it2;
                    it2 = it;
                    it2++;
                    if (it2 == soldier.end()) {
                        it = soldier.erase(it);
                        num--;
                        break;
                    } // 话说这里...好像删除最后一个结点的时候..不知道迭代器发生了什么...指不到end去了...？？？
                    it = soldier.erase(it);
                    num--;
                }
                it = soldier.begin();
                if (num &lt;= 3) {
                    break;
                }
                while (it != soldier.end() ) {
                    it++;
                    if ( it == soldier.end()) {
                        break;
                    }
                    it++;
                    if ( it == soldier.end()) {
                        break;
                    }
                    list&lt;int&gt;::iterator it2;
                    it2 = it;
                    it2++;
                    if (it2 == soldier.end()) {
                        it = soldier.erase(it);
                        num--;
                        break;
                    }
                    it = soldier.erase(it);
                    num--; 
                }
            }
            it = soldier.begin();
            cout &lt;&lt; *it;
            it++;
            for ( ; it != soldier.end(); it++) {
                cout &lt;&lt; ' ' &lt;&lt; *it ;
            }
            cout &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
<ul>
<li>第四题</li>
</ul>
<h5 id="水果">水果</h5>
<p>夏天来了~~好开心啊,呵呵,好多好多水果<br>
Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.</p>
<p>Input</p>
<p>第一行正整数N(0 &lt; N &lt;= 10)表示有N组测试数据.<br>
每组测试数据的第一行是一个整数M(0 &lt; M &lt;= 100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.</p>
<p>Output</p>
<p>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br>
两组测试数据之间有一个空行.最后一组测试数据之后没有空行.</p>
<p>Sample Input</p>
<p>1<br>
5<br>
apple shandong 3<br>
pineapple guangdong 1<br>
sugarcane guangdong 1<br>
pineapple guangdong 3<br>
pineapple guangdong 1</p>
<p>Sample Output</p>
<p>guangdong<br>
|----pineapple(5)<br>
|----sugarcane(1)<br>
shandong<br>
|----apple(3)</p>
<p>这题用map算是很合适了吧...<br>
先说下map，也是容器的一种.....<br>
好了..本来这里写了一大段，传上去以后发现，消失了！！！消失了！！难受...已经不想写了..图再发一遍吧..</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI0MjIyNjU0NTI4?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
就简单讲下吧..这是个map &lt; string, int &gt; 容器的图，但是这道题有两个关键字，第一关键字为地区，第二关键字为水果名，所以需要两个map容器。如下图：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI0MjIyOTIyODQ3?x-oss-process=image/format,png" alt=" " loading="lazy"><br>
类似于二维数组的构造（数组里面有数组），这是个map当中有map的构造，看图应该就能看懂了。一开始我一直在想，如果两个水果地区都是guangdong，那不是关键字重复了么，还查了好久关键字重复怎么办...后来画了个图就懂了，如果都是广东，在左边一列算是一个关键字，然后在右边再细分。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int N;
    string fruit, place;
    int num;
    scanf(&quot;%d&quot;, &amp;N);
    while (N--) {
        map&lt;string, map&lt;string, int&gt;&gt; myfruit;
        int M;
        cin &gt;&gt; M;
        for ( int i = 0; i &lt; M; i++) {
            cin &gt;&gt; fruit &gt;&gt; place &gt;&gt; num;
            myfruit[place][fruit] += num;
        }
        map&lt;string, map&lt;string, int&gt;&gt;::iterator it;
        map&lt;string, int&gt; :: iterator it2;
        for (it = myfruit.begin(); it != myfruit.end(); it++) {
            cout &lt;&lt; it-&gt;first &lt;&lt; endl;
            for ( it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) {
                cout &lt;&lt; &quot;   |----&quot; &lt;&lt; it2-&gt;first &lt;&lt; '(' &lt;&lt; it2-&gt;second &lt;&lt; ')' &lt;&lt; endl;
            }
        }
        if (N &gt; 0)
            cout &lt;&lt; endl;
    }
    return 0;
}

</code></pre>

            </div>
            
            <div class="prev-post">
                上一篇
                <a href="https://ccccj.github.io/xiao-jie-or-c-yu-yan-cao-zuo-fu/">
                    小结 | C语言操作符
                </a>
            </div>
            
            
            <div class="next-post">
                下一篇
                <a href="https://ccccj.github.io/acmlcm-walk/">
                    ACM：LCM Walk
                </a>
            </div>
            
        </div>
    </div>
</body>
<script>
    var t_img; // 定时器
    var isLoad = true; // 控制变量
    isImgLoad(function () {
        // 加载完成
        $('.postdetailimg').css("display", "block");
    });
    // 判断图片加载的函数
    function isImgLoad(callback) {
        // 注意我的图片类名都是cover，因为我只需要处理cover。其它图片可以不管。
        // 查找所有封面图，迭代处理
        $('.postdetailimg').each(function () {
            // 找到为0就将isLoad设为false，并退出each
            if (this.height === 0) {
                isLoad = false;
                return false;
            }
        });
        // 为true，没有发现为0的。加载完毕
        if (isLoad) {
            clearTimeout(t_img); // 清除定时器
            // 回调函数
            callback();
            // 为false，因为找到了没有加载完成的图，将调用定时器递归
        } else {
            isLoad = true;
            t_img = setTimeout(function () {
                isImgLoad(callback); // 递归扫描
            }, 500); // 我这里设置的是500毫秒就扫描一次，可以自己调整
        }
    }
</script>
        <div name="comment" style="background: white">
            <div class="commentcontainer">
                
                <head>
        <script src='https://ccccj.github.io/media/js/valine.min.js'></script>
        <script src="https://ccccj.github.io/media/js/jquery.min.js"></script>
    </head>
    <style>
        @media screen and (min-width: 1300px) {
            .v {
                margin-top: 10%;
            }
    
            .v .vwrap {
                overflow: hidden;
            }
    
            .v .vwrap {
                padding: 0 0 44px;
            }
    
            .v .veditor {
                min-height: 7rem;
                resize: none;
            }
    
            .v .vwrap .vedit {
                padding-top: 0
            }
    
            .v .vwrap .vheader {
                width: 80%;
                bottom: 0;
                position: absolute;
                background: #f7f7f7;
            }
    
            .v .vinput {
                padding: 10px 15px;
            }
    
            .v .vwrap .vheader .vinput {
                border-bottom: 0px
            }
    
            .v .vwrap .vedit .vctrl {
                margin-top: -44px;
                right: 0;
                position: absolute;
                margin-right: -3px;
            }
    
            .v .vwrap .vcontrol {
                position: absolute;
                right: 0;
                bottom: 0;
                width: 20%;
                padding-top: 0px;
            }
        }
    
        .v .vwrap .vcontrol .col.col-80 {
            width: 100%;
        }
    
        .v .vbtn.vsubmit {
            border-radius: 0;
            padding: 0;
            color: #fff;
            line-height: 44px;
            width: 100%;
            border: none;
            background: #1abc9c;
        }
    
        .v .vwrap .vedit .vctrl span.vpreview-btn,
        .v .vwrap .vcontrol .col.col-20,
        .v .vlist .vcard .vhead .vsys {
            display: none;
        }
    
        .v .vwrap .vmark .valert {
            padding-top: 0px;
        }
    
        .vtext{
            padding: 0;
        }
    
        @media screen and (max-width: 1300px) {
            .v .vwrap .vmark .valert{
                margin-top:60%;
            }
            .vwrap{
                margin: 15px;
                width: 100%;
            }
            .v .vwrap .vheader .vinput {
                padding: 10px 5px;
            }
            .v .vwrap{
                overflow: auto;
            }
            .v .veditor {
                min-height: 30rem;
                resize: none;
            }
    
            .v .vinput {
                padding: 10px 15px;
                font-size: 20px;
            }
    
            .v .vwrap .vedit .vctrl {
                right: 0;
            }
    
            .v .vempty {
                padding: 1.25em;
                text-align: center;
                color: #999;
                font-size: 25px;
            }
    
        }
    </style>
    
    <body>
        <div id="vcomments1"></div>
        <script>
            new Valine({
                el: '#vcomments1',
                appId: '1',
                appKey: '2',
                notify: true,
                verify: false,
                avatar: 'retro',
                pageSize: 30,
                placeholder: '既然来了，那就留个痕迹吧~',
            })
        </script>
    </body>
                <div class="clear"></div>
                
            </div>
        </div>
    </div>
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</body>
<script>
    hljs.initHighlightingOnLoad()
</script>
<script src="https://ccccj.github.io/media/js/post.js"></script>
