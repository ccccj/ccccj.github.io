<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ccccj.github.io</id>
    <title>Amon&apos;s Homepage</title>
    <updated>2022-02-26T08:11:51.982Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ccccj.github.io"/>
    <link rel="self" href="https://ccccj.github.io/atom.xml"/>
    <logo>https://ccccj.github.io/images/avatar.png</logo>
    <icon>https://ccccj.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Amon&apos;s Homepage</rights>
    <entry>
        <title type="html"><![CDATA[从零实现隧道穿透（四）：隧道穿透原理详解]]></title>
        <id>https://ccccj.github.io/5_ZcDCobO/</id>
        <link href="https://ccccj.github.io/5_ZcDCobO/">
        </link>
        <updated>2022-01-20T09:25:19.000Z</updated>
        <content type="html"><![CDATA[<p><mark>一、原理</mark></p>
<p>项目地址为：https://github.com/ccccj/Socks5Server</p>
<blockquote>
<p>不是网络之类的专业，所以了解的不太清楚，仅自己的理解。</p>
</blockquote>
<ul>
<li>
<p>学网络的时候我们知道，若两个节点之间不支持 IPv6，比如3号节点与4号节点之间不支持，就需要在3号的前一个节点（2号），将整个 IPv6 的数据包，封装一层 IPv4 的头部，原本的头部+数据，全部变成新的数据。而在4号节点的后一个节点（5号），解封装 IPv4 的头部，将其重新变为 IPv6 数据包。</p>
</li>
<li>
<p>这一段通道，我们称之为隧道。按我的理解来看，隧道就是对原本的数据包加一层封装，因此有很多不同的隧道。我这里写的是加一层 Socks5 协议的头部，将原本的目的 IP 隐藏的数据中，从而可以绕开防火墙，比如通常大家用 VPN 来翻墙。</p>
</li>
<li>
<p>也就是 本地浏览器 A，将数据封装了 Socks5 的头部，发往 C 服务器（称之为 Socks5服务器），Socks5服务器需要对头部进行解析，把原本的数据剥离出来，再发给真正的目标服务器。若防火墙在 A、C之间，就可以绕开防火墙（绕开限制了目标 IP 的防火墙）。</p>
</li>
<li>
<p>但是如果 本地浏览器 A、Socks5服务器之间还存在内容过滤，比如有的公司会监测员工平时浏览的网站，要想公司的防火前发现不了自己访问的数据，就需要在 本地浏览器 A、Socks5服务器之间再加一个 中转服务器B，对数据进行加密，加密后再将数据发给 Socks5服务器。若防火墙在 中转服务器B 和 Socks5服务器之间进行内容过滤，我们的加密就可以让其看不到自己真实想访问的数据。</p>
</li>
<li>
<p>而 Socks5服务器此时要先将拿到的数据进行解密，再解析 Socks5协议，最后再将数据转发给目标服务器。目标服务器将返回的数据传给 Socks5服务器，由 Socks5服务器进行加密，再传给中转服务器B，B 对数据进行解密，最后返还给本地浏览器 A。</p>
</li>
</ul>
<p>发送数据时的流程如下：</p>
<figure data-type="image" tabindex="1"><img src="https://ccccj.github.io/post-images/1645853190900.png" alt="" loading="lazy"></figure>
<p>图中只显示了转发出去的流程，转发回来也是一样的。只是不需要 Socks5的认证了，两个服务器对数据进行加密或解密，再直接转发即可。</p>
<p><mark>二、Transfe.cpp</mark></p>
<p>先说明一下，Socks5服务器 等于 服务器C。</p>
<p>服务器B 上运行的 Transfer.cpp，主要实现加密和转发的功能。</p>
<p>在这里，我们给 服务器B 和 服务器C 各开放一个端口，假设给 服务器B 监听 5678端口，服务器C 监听7890端口。</p>
<p>浏览器会尝试连接 服务器B的5678端口，连上后将数据发送给 服务器B。而 服务器B需要 请求连接服务器C 的7890端口。</p>
<p>在 A-&gt;B 之间，可以理解为 A是客户端，B是服务器端。在 B-&gt;C 之间，可以理解为 B是客户端，C是服务器端。在 C-&gt;D 之间，可以理解为 C是客户端，D是服务器端。</p>
<p>最复杂的地方在于，我们要处理好并发的关系。在这里我选择了使用 epoll 来处理并发（在前面的博客里）。</p>
<p>epoll 要监测的事件分为三种：</p>
<ul>
<li>
<p>对于 main_fd 的监测，mian_fd 用于监听端口5678，当客户端尝试连接时，就触发了mian_fd的事件。对该事件的处理，也就是创建一个新的套接字描述符，用于接收客户端的数据；同时创建一个套接字描述符，用于请求连接Socks5服务器，用于后续的把数据加密后发给Socks5服务器；这时候两个套接字描述符进行epoll的注册，用于后续的对他们的读监听（两个都要是因为，无论是客户端还是Socks5服务器，都有可能给B发数据）。</p>
</li>
<li>
<p>对于集合内文件描述符的读监听。无论是客户端还是Socks5服务器进行连接的套接字描述符，触发读监听时说明有数据发来，我们对其进行读（recv），并进行转发（发给另一端）即可。但发送时有可能发不完（比如缓冲区满了）。如果发生这种情况，需要我们将该文件描述符进行写监听，后续对方读取数据后，缓冲区可以放新数据了，这时候就会触发这个写事件（我们这里用的是非阻塞）。</p>
</li>
<li>
<p>对于集合内文件描述符的写监听。是由于发送（send）的实际发送长度小于要发送的长度引起的。再次发送并判断是否发完即可。若没有发完，和上一步一样，将该文件描述符进行写监听。</p>
</li>
</ul>
<p>这一步的代码如下：</p>
<pre><code>   _events_fd = epoll_create(10000);
   events_ctl(_main_fd, EPOLL_CTL_ADD, EPOLLIN);
   struct epoll_event events[100000];
   
   while (1) {
       int num = epoll_wait(_events_fd, events, 100000, 0);
       
       for (int i = 0; i &lt; num; ++i) {
           if (events[i].data.fd == _main_fd) {
               // 监测连接请求
               connect_handler();
           } else if(events[i].events &amp; (EPOLLIN | EPOLLPRI)) {
               read_handler(events[i].data.fd);
           } else if(events[i].events &amp; EPOLLOUT) {
               PriInfo(&quot;write events！&quot;);
               write_handler(events[i].data.fd);
           } else{
               // ...
           }
       }
   }
</code></pre>
<p>还有一个问题就是，由于连接请求都是并发的，我们要对B的每一个套接字描述符进行存储，比如，和浏览器A进行连接的是套接字描述符是9，对于9发来的数据，要发给C，和C连接的套接字描述符是10，那么9-10这一对套接字描述符要存储好。具体可以看github的代码。</p>
<p>同时，对于没发完的数据，也要记录该数据是哪个套接字描述符发来的，将要用哪个套接字描述符发出去。</p>
<p>最后，关于加密方式，由于我写的只是一个小demo，并未采取什么高端的加密方式，但改一下加密的函数即可。</p>
<p><mark>三、SocksServer.cpp</mark></p>
<p>Socks5服务器 和服务器B 最大的不同就是，要对 <strong>B</strong> 发来的认证（实际上是浏览器发来的）进行回复。</p>
<p>结合 VPN实现（三）来看。</p>
<pre><code>    +---------+---------------+-----------+
    | VERSION | METHODS_COUNT |  METHODS  |
    +---------+---------------+-----------+
    |   0x05  |       1       |   '00'    |
    +---------+---------------+-----------+
</code></pre>
<p>第一次的认证，要判断第一个字节是不是第一个字节是不是 0x05。如果是的话，返回 0x05,0x00 一共两个字节即可。（0x00表示选择的不加密的认证）</p>
<pre><code>    +---------+---------+-------+------+----------+----------+
    | VERSION | COMMAND |  RSV  | TYPE | DST.ADDR | DST.PORT |
    +---------+---------+-------+------+----------+----------+
    |    1    |    1    |   1   |  1   | Variable |    2     |
    +---------+---------+-------+------+----------+----------+
</code></pre>
<p>第二次的认证，要判断第一个字节是不是第一个字节是不是 0x05。如果是的话，再判断第四个字节 TYPE 的值是多少。因为我们不支持 ipv6，所以这个字段不能是 0x04（代表ipv6）。<br>
如果这个字段是 0x01 的话，说明下一个字段是 ip 地址。所以读取下一个字段4字节，再读取2字节的端口即可。<br>
如果这个字段是 0x03 的话，说明下一个字段是域名。</p>
<p>当然，我们每次读取发来的数据，都要先进行解密，才能读取。发回给 <strong>B</strong> 的数据，也要先加密再发。</p>
<p>在这一个过程中，我们已经知道了 ip 和端口，可以和目标服务器 <strong>D</strong> 建立连接。建立完连接，后面就可以发数据了。</p>
<p>因为我们不知道目前到了第几个认证步骤，所以要分成三个状态。第一个状态是 STEP1，代表还未进行认证。第二个状态是 STEP2，代表第一步的认证已经完成。第三个状态是 FORWARD，代表代表第二步的认证已经完成，已经可以进行数据转发了。</p>
<p>每次完成一个认证步骤，就将状态修改。</p>
<pre><code>    if (con-&gt;_state == STEP1) {
            int ret = negotiation1(fd); // 自己写的认证函数
            if (ret == 1) {
                con-&gt;_state = STEP2;
            } else if (ret == -1) {
                // 失败
            }
        } else if (con-&gt;_state == STEP2) {
            char ret[10];
            memset(ret, 0, 10);
            ret[0] = 0x05;
            int right_fd = negotiation2(fd); // 自己写的认证函数

            if (right_fd &gt; 0) {
                // 认证成功 ...
                con-&gt;_state = FORWARD;
            } else if (right_fd == -1) {
                // 认证失败 ...
            }
        } else if (con-&gt;_state == FORWARD) {
            // 转发数据
        } else {
            // ...
        }
    }
</code></pre>
<p>关于认证过程不细写了，可以看github的代码。</p>
<p><mark>四、不足</mark></p>
<p>1、两个服务器的很多功能还是比较相似的，可以进行复用，但是我写的比较粗糙，是单独的两个文件。<br>
2、很多功能都不支持，比如不支持ipv6、不支持udp、不支持加密认证等等，很多情况都粗暴的报错处理了。<br>
3、代码还是有一些bug存在，比如我的浏览器插件，只会发送域名而不是ip的情况，发送ip的情况并没有测试bug。<br>
4、加密用的异或加密，主要是方便，因为不管加密还是解密代码都一样，不用传参细分..但实在是有些low了。</p>
<p>参考：<br>
https://www.cnblogs.com/0xl4k1d/p/15664414.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零实现隧道穿透（三）：epoll 用法]]></title>
        <id>https://ccccj.github.io/DsL-QRlE1/</id>
        <link href="https://ccccj.github.io/DsL-QRlE1/">
        </link>
        <updated>2022-01-12T07:29:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="int-epoll_createint-size">int epoll_create(int size);</h3>
<ul>
<li>作用：创建一个 epoll 的句柄。</li>
<li>参数：size 用来告诉内核监听的数目大小，内核会根据 size 的大小去申请对应的内存。</li>
<li>返回值：成功则返回新的 epoll 对象的文件描述符，这个文件描述符用于后续的 epoll 操作。如果不需要使用这个描述符，使用 close 关闭。失败返回 -1 。</li>
</ul>
<h3 id="int-epoll_create1int-flags">int epoll_create1(int flags);</h3>
<ul>
<li>作用：创建一个 epoll 的句柄。</li>
<li>参数：flags的值是 0，epoll_create1()等同于epoll_create()。但是不再根据 size 大小申请内存。而是动态申请内存。flasg 还可以使用其他值。</li>
<li>返回值：成功返回文件描述符。失败返回 -1 。</li>
</ul>
<h3 id="int-epoll_ctlint-epfd-int-op-int-fd-struct-epoll_event-event">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</h3>
<ul>
<li>作用：事件注册函数。我个人的理解就是将要监测的目标 fd 添加进 epfd 中。</li>
<li>参数：epfd 是 epoll_create 的返回值。op：添加事件的类型选项。fd：目标文件描述符（需要监听的目标）。event 告诉内核需要监听什么事。</li>
<li>返回值：成功返回 0 ，失败返回 -1 。</li>
</ul>
<p>op 宏（添加事件的类型选项）有以下几种：</p>
<pre><code>EPOLL_CTL_ADD：在 epfd 中注册新的 fd ，对这个 fd 要监听的是 event。
EPOLL_CTL_MOD：改变已注册到 epfd 的 fd 的监听事件。即改成新的 event。
EPOLL_CTL_DEL：从指定的 epfd 中 删除 fd 文件描述符。在这种模式中 event 是被忽略的，并且为可以等于 NULL 。
</code></pre>
<p>struct epoll_event（需要监听的事）结构如下：</p>
<pre><code>struct epoll_event {
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};
</code></pre>
<p>events 宏有以下几种，可以取他们的并：</p>
<p>EPOLLIN ：表示对应的文件描述符执行读时；<br>
EPOLLOUT：表示对应的文件描述符执行写时；<br>
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>
EPOLLERR：表示对应的文件描述符发生错误；<br>
EPOLLHUP：表示对应的文件描述符被挂断；<br>
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<p>epoll_data 的结构如下：</p>
<pre><code>typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;
</code></pre>
<p>一般用法是这样的：</p>
<pre><code>struct epoll_event e;
e.data.fd = socket_fd;
e.events = EPOLLIN | EPOLLOUT;
epoll_ctl(events_fd, EPOLL_CTL_MOD, socket_fd, &amp;e);
</code></pre>
<h3 id="int-epoll_waitint-epfd-struct-epoll_event-events-int-maxevents-int-timeout">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</h3>
<ul>
<li>作用：等待 epfd 中的事件。类似于select()调用。</li>
<li>参数：events 用来从内核得到事件的集合。maxevents 告知内核有多少个 events，必须要大于0。timeout 是用来制定epoll_wait 会阻塞多少毫秒的。</li>
</ul>
<p>关于 events 的用法一般是这样的：</p>
<pre><code>struct epoll_event events[100000]; // 一个数组
// num 告知用户有多少个事件被监听到，并且这些事件放在 events 数组里了
int num = epoll_wait(epfd, events, 100000, 0); 

// 循环查看 num 个事件
for (int i = 0; i &lt; num; ++i) {
    if (events[i].events &amp; (EPOLLIN | EPOLLPRI)) {
        // 表示对应的文件描述符执行读；即，events[i].data.fd 执行读
        // ...
    } else if (events[i].events &amp; EPOLLOUT) {
        // 表示对应的文件描述符执行写；即，events[i].data.fd 执行写
        // ...
    } else{
        // ...
    }
}
</code></pre>
<p>参考：<br>
https://www.jianshu.com/p/ee381d365a29</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零实现隧道穿透（二）：socks5 协议详解]]></title>
        <id>https://ccccj.github.io/5t8AeFn9p/</id>
        <link href="https://ccccj.github.io/5t8AeFn9p/">
        </link>
        <updated>2022-01-08T09:31:44.000Z</updated>
        <content type="html"><![CDATA[<p>socks的文档：https://www.ietf.org/rfc/rfc1928.txt<br>
SOCKS5 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 &quot;Sockets&quot;的缩写。<br>
SOCKS5 工作在比 HTTP 代理更低的层次。<br>
是一个代理协议，它在使用TCP/IP协议通讯的前端机器和服务器机器之间扮演一个中介角色，使得内部网中的前端机器变得能够访问Internet网中的服务器，或者使通讯更加安全。SOCKS5 服务器通过将前端发来的请求转发给真正的目标服务器，模拟了一个前端的行为。在这里，前端和SOCKS5之间也是通过TCP/IP协议进行通讯，前端将原本要发送给真正服务器的请求发送给SOCKS5服务器，然后SOCKS5服务器将请求转发给真正的服务器。</p>
<h2 id="一-第一步客户端发送的报头"><mark>一、第一步——客户端发送的报头</mark></h2>
<table>
<thead>
<tr>
<th style="text-align:center">VERSION</th>
<th style="text-align:center">METHODS_COUNT</th>
<th style="text-align:center">METHODS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1到255字节，长度由METHODS_COUNT值决定</td>
</tr>
<tr>
<td style="text-align:center">0x05</td>
<td style="text-align:center">0x03</td>
<td style="text-align:center">……</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>VERSION：socks 版本，这里用的是 socks5，所以是0x05。</p>
</li>
<li>
<p>METHODS_COUNT： METHODS 部分的长度。</p>
</li>
<li>
<p>METHODS：代表客户端拥有的加密方式。每个方法占 1 字节。当前的定义是：</p>
<ul>
<li>0x00 不加密</li>
<li>0x01 GSSAPI</li>
<li>0x02 用户名、密码认证</li>
<li>0x03 - 0x7F 由IANA分配（保留）</li>
<li>0x80 - 0xFE 为私人方法保留</li>
<li>0xFF 无可接受的方法</li>
</ul>
</li>
</ul>
<p>例如，客户端发送的 5 2 0 2，代表 版本5 有两种握手方式 “不加密”和“用户名、密码认证”供代理选择。</p>
<p>因为我们写的是服务器端，怎么发过来是客户端（浏览器）解决的，所以这里不用管。</p>
<h2 id="二-第二步代理服务器响应的报头"><mark>二、第二步——代理服务器响应的报头</mark></h2>
<table>
<thead>
<tr>
<th style="text-align:center">VERSION</th>
<th style="text-align:center">METHODS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
</tr>
<tr>
<td style="text-align:center">0x05</td>
<td style="text-align:center">从客户端发送的加密方式里面选一个</td>
</tr>
</tbody>
</table>
<ul>
<li>VERSION：socks 版本，这里用的是 socks5，所以是0x05。</li>
<li>METHODS：代表代理服务器选择了一种握手方式。占 1 字节。</li>
</ul>
<p>例如，代理服务器发送的 5 0，代表 版本5 选择了“不加密”的握手方式。</p>
<p>如果客户端的所有握手方式代理服务器都不满足，直接断开连接。</p>
<p>如果代理服务器发送 5 2，代表 版本5 选择了“用户名、密码认证”的握手方式。此时客户端会发送账号密码数据给代理服务器，再由代理服务器检验，并返回结果。格式如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">VERSION</th>
<th style="text-align:center">USERNAME_LENGTH</th>
<th style="text-align:center">USERNAME</th>
<th style="text-align:center">PASSWORD_LENGTH</th>
<th style="text-align:center">PASSWORD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1-255字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1-255字节</td>
</tr>
<tr>
<td style="text-align:center">0x01</td>
<td style="text-align:center">0x01</td>
<td style="text-align:center">……</td>
<td style="text-align:center">0x01</td>
<td style="text-align:center">……</td>
</tr>
</tbody>
</table>
<ul>
<li>VERSION：认证子协商版本（与 SOCKS 协议版本的0x05无关系）</li>
<li>USERNAME_LENGTH：用户名长度</li>
<li>USERNAME：用户名字节数组，长度为 USERNAME_LENGTH</li>
<li>PASSWORD_LENGTH：密码长度</li>
<li>PASSWORD：密码字节数组，长度为 PASSWORD_LENGTH</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">VERSION</th>
<th style="text-align:center">USERNAME_LENGTH</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
</tr>
<tr>
<td style="text-align:center">0x01</td>
<td style="text-align:center">0x01</td>
</tr>
</tbody>
</table>
<ul>
<li>VERSION：认证子协商版本，与客户端 VERSION 字段一致</li>
<li>STATUS：认证结果（0x00 认证成功 / 大于0x00 认证失败）</li>
</ul>
<p>这里需要我们的服务器端做出回应。</p>
<pre><code>    char buf[4096];
    int len = recv(fd, buf, sizeof(buf), 0);
    if (len &gt; 0) {
        char ret[2];
        ret[0] = 0x05;

        if (buf[0] == 0x05) { // 是 socks5
            ret[1] = 0x00; // 选择 不加密方式
            XORcode(ret, 2);
            send(fd, ret, sizeof(ret), 0);
        } else {
            // ...
        }
    } else {
        // ...
    }
</code></pre>
<h2 id="第三步客户端发送需要访问的ip和端口以及协议"><mark>第三步——客户端发送需要访问的IP和端口，以及协议</mark></h2>
<table>
<thead>
<tr>
<th style="text-align:center">VERSION</th>
<th style="text-align:center">COMMAND</th>
<th style="text-align:center">RSV</th>
<th style="text-align:center">ADDRESS_TYPE</th>
<th style="text-align:center">DST.ADDR</th>
<th style="text-align:center">DST.PORT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">可变成长度</td>
<td style="text-align:center">2字节</td>
</tr>
</tbody>
</table>
<ul>
<li>VERSION：SOCKS 协议版本，固定 0x05</li>
<li>COMMAND：命令
<ul>
<li>0x01：CONNECT请求，连接上游服务器（使用TCP）</li>
<li>0x02：BIND 绑定，客户端会接收来自代理服务器的链接，著名的FTP被动模式</li>
<li>0x03：UDP ASSOCIATE UDP 中继（UDP 转发）</li>
</ul>
</li>
<li>RSV：保留字段，无实际作用</li>
<li>ADDRESS_TYPE：目标服务器地址类型
<ul>
<li>0x01：表示 IPv4 地址</li>
<li>0x03：域名地址(没有打错，就是没有0x02)</li>
<li>0x04：IPv6 地址</li>
</ul>
</li>
<li>DST.ADDR：目标服务器地址（如果是ipv6，该字段的第一个字节是域名长度，剩下字节为域名）</li>
<li>DST.PORT：目标服务器端口</li>
</ul>
<p>因为我们写的是服务器端，这一步在下一步里面进行判断即可。</p>
<h2 id="第四步代理服务器响应"><mark>第四步——代理服务器响应</mark></h2>
<table>
<thead>
<tr>
<th style="text-align:center">VERSION</th>
<th style="text-align:center">RESPONSE</th>
<th style="text-align:center">RSV</th>
<th style="text-align:center">ADDRESS_TYPE</th>
<th style="text-align:center">BND.ADDR</th>
<th style="text-align:center">BND.PORT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">1-255字节</td>
<td style="text-align:center">2字节</td>
</tr>
</tbody>
</table>
<ul>
<li>VERSION：SOCKS 协议版本，固定 0x05</li>
<li>RESPONSE：响应命令
<ul>
<li>0x00：代理服务器连接目标服务器成功</li>
<li>0x01：代理服务器故障</li>
<li>0x02：代理服务器规则集不允许连接</li>
<li>0x03：网络无法访问</li>
<li>0x04：目标服务器无法访问（主机名无效）</li>
<li>0x05：连接目标服务器被拒绝</li>
<li>0x06：TTL已过期</li>
<li>0x07：不支持的命令</li>
<li>0x08：不支持的目标服务器地址类型</li>
<li>0x09 - 0xFF：未分配</li>
</ul>
</li>
<li>RSV：保留字段</li>
<li>ADDRESS_TYPE：后面的地址类型
<ul>
<li>0x01：ipv4</li>
<li>0x03：域名</li>
<li>0x04：ipv6</li>
</ul>
</li>
<li>BND.ADDR：代理服务器连接目标服务器成功后的代理服务器 IP</li>
<li>BND.PORT：代理服务器连接目标服务器成功后的代理服务器端口</li>
</ul>
<pre><code>    char buf[4096];
    int len = recv(fd, buf, 4, 0);
    if (len &lt;= 0) return -1;
    if (len &lt; 4) return 0;

    if (buf[0] != 0x05 || buf[2] != 0x00) return -1;
    
    char ip4[MAXLINE], port[5];

    if (buf[3] == 0x04) { // 如果是 ipv6
        // ...
    } else if (buf[3] == 0x01) { // 如果是 ipv4
        len = recv(fd, ip4, 4, 0);
        len = recv(fd, port, 2, 0);

        ip4[4] = '\0';
        port[2] = '\0';
        int client_fd = open_clientfd(ip4, port); 
        // ...
    } else if (buf[3] == 0x03) { // 是用域名表示的
        // 域名字段中第一个字节是真实的域名的长度，后面才是真实的域名
        char doname_len;
        char doname[MAXLINE];
        len = recv(fd, &amp;doname_len, 1, 0);
       
        if (len &lt; 1) return 0;

        len = recv(fd, doname, doname_len, 0);
        doname[len] = '\0';

        struct hostent* host = gethostbyname(doname);
        
        memcpy(ip4, host-&gt;h_addr, host-&gt;h_length);
        len = recv(fd, port, 2, 0);

        int client_fd = socket(AF_INET, SOCK_STREAM, 0);
        struct sockaddr_in server;
        server.sin_family = AF_INET;
        memcpy(&amp;server.sin_addr.s_addr, ip4, 4);
        server.sin_port = *((uint16_t*)port);

        connect(client_fd, (struct sockaddr*)&amp;server, sizeof(server));
        return client_fd;

    } else {
        return -1;
    }
}
</code></pre>
<h2 id="第五步通信"><mark>第五步——通信</mark></h2>
<p>把要发的内容，像正常的socket编程发过去即可。</p>
<p>参考：<br>
https://www.jianshu.com/p/91979534b49d<br>
https://www.ddhigh.com/2019/08/24/socks5-protocol.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零实现隧道穿透（一）：socket编程记录]]></title>
        <id>https://ccccj.github.io/pt2KSNu0F/</id>
        <link href="https://ccccj.github.io/pt2KSNu0F/">
        </link>
        <updated>2022-01-02T06:22:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="总览">总览：</h2>
<figure data-type="image" tabindex="1"><img src="https://ccccj.github.io/post-images/1641806453532.png" alt="" loading="lazy"></figure>
<h2 id="注意">注意：</h2>
<pre><code>如果是买的云服务器，开放端口除了要在服务器上设置一下，还要再购买的网站的控制台处设置一下。
</code></pre>
<h2 id="客户端"><mark>【客户端】</mark></h2>
<h3 id="1-int-socketint-family-int-type-int-protocol">1、int socket(int family, int type, int protocol);</h3>
<h4 id="作用">【作用】</h4>
<pre><code>创建一个套接字描述符，用 getaddrinfo 自动生成参数配合使用
</code></pre>
<h4 id="参数">【参数】</h4>
<pre><code>family：指明了协议族/域，通常AF_INET、AF_INET6、AF_LOCAL等
type：套接口类型，主要 SOCK_STREAM、SOCK_DGRAM、SOCK_RAW
protocol：一般取为0。成功时，返回一个小的非负整数值，与文件描述符类似
</code></pre>
<h4 id="返回值">【返回值】</h4>
<pre><code>OK(非负)，error(-1)
</code></pre>
<h3 id="2-int-connectint-clientfd-const-struct-sockaddr-addr-socklen_t-addrlen">2、int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);</h3>
<h4 id="作用-2">【作用】</h4>
<pre><code>客户端用来建立和服务器的连接（指定S端点地址），用 getaddrinfo 自动生成参数配合使用
</code></pre>
<h4 id="参数-2">【参数】</h4>
<pre><code>第一个参数是，通过 socket 得到的描述符，
</code></pre>
<h4 id="返回值-2">【返回值】</h4>
<pre><code>OK(0)，error(-1)
</code></pre>
<h3 id="3-closesocket">3、closesocket：</h3>
<pre><code>释放套接字
</code></pre>
<h2 id="服务器端"><mark>【服务器端】</mark></h2>
<h3 id="1-int-socketint-family-int-type-int-protocol-2">1、int socket(int family, int type, int protocol);</h3>
<h4 id="作用-3">【作用】</h4>
<pre><code>创建一个套接字描述符，用 getaddrinfo 自动生成参数配合使用
</code></pre>
<h4 id="参数-3">【参数】</h4>
<pre><code>family：指明了协议族/域，通常AF_INET、AF_INET6、AF_LOCAL等
type：套接口类型，主要 SOCK_STREAM、SOCK_DGRAM、SOCK_RAW
protocol：一般取为0。成功时，返回一个小的非负整数值，与文件描述符类似
</code></pre>
<h4 id="返回值-3">【返回值】</h4>
<pre><code>OK(非负)，error(-1)
</code></pre>
<h3 id="2-int-bindint-sockfd-const-struct-sockaddr-addr-socklen_t-addrlen">2、int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</h3>
<h4 id="作用-4">【作用】</h4>
<pre><code>服务器用来绑定本地端点地址（创建 主套接字），用 getaddrinfo 自动生成参数配合使用
</code></pre>
<h4 id="返回值-4">【返回值】</h4>
<pre><code>OK(0)，error(-1)
</code></pre>
<h3 id="3-int-listenint-sockfd-int-backlog">3、int listen(int sockfd, int backlog);</h3>
<h4 id="作用-5">【作用】</h4>
<pre><code>只用于TCP，将主动套接字转化为监听套接字，设置队列大小（backlog，通常设置为较大的值）
</code></pre>
<h4 id="返回值-5">【返回值】</h4>
<pre><code>OK(0)，error(-1)
</code></pre>
<h3 id="4-int-acceptint-listenfd-struct-sockaddr-addr-int-addrlen">4、int accept(int listenfd, struct sockaddr *addr, int *addrlen);</h3>
<h4 id="作用-6">【作用】</h4>
<pre><code>只用于TCP，会创建一个新的套接字（和客户端关联起来了的套接字），使用这个新的套接字和客户端进行通信，用于并发。本函数会阻塞等待直到有客户端请求到达。
</code></pre>
<h4 id="参数-4">【参数】</h4>
<pre><code>addr：存放客户端的地址
addrlen：在调用函数时被设置为 addr 指向区域的长度，在函数调用结束后被设置为实际地址信息的长度
</code></pre>
<h4 id="返回值-6">【返回值】</h4>
<pre><code>OK(新的 fd )，error(-1)
返回的 fd 是一个新的套接字描述符，它代表的是和客户端的新的连接，可以把它理解成是一个客户端的socket, 这个socket包含的是客户端的ip和port信息 。（当然这个new_socket会从sockfd中继承 服务器的ip和port信息，两种都有了），而参数中的SOCKET   s包含的是服务器的ip和port信息 。
之后的 send 和 recv 函数中的 fd 都是指这个 new_fd。
</code></pre>
<h2 id="getaddrinfo自动生成参数"><mark>【getaddrinfo自动生成参数】</mark></h2>
<h3 id="int-getaddrinfoconst-char-hostname-const-char-service-const-struct-addrinfo-hints-struct-addrinfo-result">int getaddrinfo(const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result);</h3>
<h4 id="作用-7">【作用】</h4>
<pre><code>主机名、主机地址、服务名、端口号的字符串表示 -&gt; 套接字
</code></pre>
<h4 id="返回值-7">【返回值】</h4>
<pre><code>返回值：OK(0), error(非0)
</code></pre>
<h4 id="参数-5">【参数】</h4>
<pre><code>hostname：主机名或地址串(IPv4的点分十进制串或者 IPv6的16进制串)
service：十进制的端口号，或是已定义的服务名称，如ftp、http等

hints：空指针，或是一个指向某个 addrinfo 结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。
举例来说：如果指定的服务既支持 TCP 也支持 UDP，那么调用者可以把 hints 结构中的 ai_socktype 成员设置成 SOCK_DGRAM 使得返回的仅仅是适用于数据报套接口的信息。
必须先分配一个 hints 结构，把它清零后填写需要的字段

result：一个指向 addrinfo 结构体链表的指针。用于后续的 socket 函数。默认最多返回 3 个 addrinfo 结构。调用 getaddrinfo 后遍历链表，逐个尝试每个返回地址。
</code></pre>
<h4 id="hints-和-result-的结构">hints 和 result 的结构：</h4>
<pre><code>struct addrinfo {
    int ai_flags;    // Hints argument flags
    int ai_family;   // AF_INET（ipv4）或 AF_INET6（ipv6）
    int ai_socktype; // SOCK_STREAM（TCP流）或 SOCK_DGRAM（UDP数据报）
    int ai_protocol; // 一般为 0 不做修改
    char *ai_canonname; // Canonical hostname
    size_t ai_addrlen;  //Size of ai_addr struct
    struct sockaddr *ai_addr; // Ptr to socket address structure
    struct addrinfo *ai_next; // Ptr to next item in linked list
};
</code></pre>
<p>其中，</p>
<pre><code>struct sockaddr {
    uint16_t  sa_family;    // Protocol family
    char      sa_data[14];  // Address data
};
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ccccj.github.io/post-images/1641797684538.png" alt="" loading="lazy"></figure>
<p>ai_flags：可以把各种值用 OR 组合起来得到该掩码。<br>
hint.ai_flags常用：<br>
AI_ADDRCONFIG：在使用连接时设置这个。<br>
AI_CANONNAME：ai_canonname 默认为 NULL。设置这个标志后，将链表里第一个结构的 ai_canonname 指向主机的？？？<br>
AI_NUMERICSERV：原本 getaddrinfo 第二个参数，可以为服务名或端口号，设置后强制为端口号。<br>
AI_PASSIVE：返回的套接字地址为服务器监听套接字。此时 hostname 为 NULL</p>
<h3 id="void-freeaddrinfostruct-addrinfo-res">void freeaddrinfo(struct addrinfo *res);</h3>
<pre><code>用完必须释放。res 参数指向链表中第一个 addrinfo 结构。这个链表中的所有结构以及它们指向的任何动态存储空间都被释放掉。
</code></pre>
<h3 id="const-char-gai_strerrorint-error">const char *gai_strerror(int error);</h3>
<pre><code>打印错误信息：该函数以 getaddrinfo 返回的非 0 错误值的名字和含义为他的唯一参数，返回一个指向对应的出错信息串的指针。
</code></pre>
<p>其他还有：<br>
getprotobyname：协议名-&gt;协议号<br>
getservbyname：服务名-&gt;熟知端口号<br>
但是我没用到。</p>
<h2 id="接收和发送数据"><mark>【接收和发送数据】</mark></h2>
<h3 id="1-int-recvint-fd-char-buf-int-len-int-flags">1、int recv(int fd, char *buf, int len, int flags);</h3>
<h4 id="作用-8">【作用】</h4>
<pre><code>客户端或服务器，接收数据。
</code></pre>
<h4 id="参数-6">【参数】</h4>
<pre><code>fd：接收端套接字描述符；
buf：缓冲区，该缓冲区用来存放 recv 函数接收到的数据
len：buf 的长度
flags：一般置 0
</code></pre>
<h4 id="返回值-8">【返回值】</h4>
<pre><code>失败时，返回值小于0；超时或对端主动关闭，返回值等于0；成功时，返回值是返回接收数据的长度
</code></pre>
<h3 id="2-int-sendint-fd-const-char-buf-int-len-int-flags">2、int send(int fd, const char *buf, int len, int flags);</h3>
<h4 id="作用-9">【作用】</h4>
<pre><code>发送数据
</code></pre>
<h4 id="参数-7">【参数】</h4>
<pre><code>fd：指定发送端套接字描述符
buf：要发送数据的缓冲区
len：实际要发送的数据的字节数
flags：一般置0
</code></pre>
<h4 id="返回值-9">【返回值】</h4>
<pre><code>失败时，返回值小于0；超时或对端主动关闭，返回值等于0；成功时，返回值是返回发送数据的长度。
</code></pre>
<h2 id="字节顺序转换"><mark>【字节顺序转换】</mark></h2>
<h3 id="1-uint32_t-htonluint32_t-hostlong">1、uint32_t htonl(uint32_t hostlong);</h3>
<ul>
<li>主机字节顺序 转换为 网络字节顺序（32位）</li>
</ul>
<h3 id="2-uint32_t-ntohluint32_t-netlong">2、uint32_t ntohl(uint32_t netlong);</h3>
<ul>
<li>网络字节顺序 转换为 主机字节顺序（32位）</li>
</ul>
<h2 id="ip格式转换"><mark>【ip格式转换】</mark></h2>
<h3 id="1-int-inet_ptonaf_inet-const-char-src-void-dst">1、int inet_pton(AF_INET, const char *src, void *dst);</h3>
<ul>
<li>点分十进制ip -&gt; 二进制网络字节顺序ip</li>
<li>Returns: 1 if OK, 0 if src is invalid dotted decimal, −1 on error</li>
</ul>
<h3 id="2-const-char-inet_ntopaf_inet-const-void-src-char-dst-socklen_t-size">2、const char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size)：</h3>
<ul>
<li>二进制网络字节顺序ip -&gt; 点分十进制ip</li>
<li>size：目标存储单元的大小</li>
<li>Returns: pointer to a dotted-decimal string if OK, NULL on error<br>
注：可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）</li>
</ul>
<h2 id="套接字格式"><mark>【套接字格式】</mark></h2>
<pre><code>// IP socket address structure
struct sockaddr_in  {
    uint16_t sin_family;  // Protocol family (always AF_INET)
    uint16_t sin_port;    // Port number in network byte order
    struct in_addr sin_addr; // IP address in network byte order
    unsigned char sin_zero[8]; // Pad to sizeof(struct sockaddr)
};
// Generic socket address structure (for connect, bind, and accept)
struct sockaddr {
    uint16_t  sa_family;    // Protocol family
    char      sa_data[14];  // Address data
};
</code></pre>
<h2 id="域名与ip转换"><mark>【域名与ip转换】</mark></h2>
<h3 id="struct-hostent-gethostbynameconst-char-name">struct hostent *gethostbyname(const char *name);</h3>
<ul>
<li>域名-&gt;32位ip地址（返回的是按网络字节顺序的）</li>
<li>返回结构：</li>
</ul>
<pre><code>struct hostent {
    char    *h_name; // 主机的规范名
    char    **h_aliases; // 主机的别名
    int     h_addrtype; // 主机ip地址的类型ipv4(AF_INET)，pv6(AF_INET6)
    int     h_length; // 主机ip地址的长度
    char    **h_addr_list; // 主机的ip地址（网络字节序），打印需要调用inet_ntop()
};
</code></pre>
<h2 id="inet_addr"><mark>【inet_addr】</mark></h2>
<h3 id="in_addr_t-inet_addrconst-char-cp">in_addr_t inet_addr(const char *cp);</h3>
<p>将一个点分十进制的IP转换成一个长整数型数（u_long类型）</p>
<h2 id="代码">代码</h2>
<p>服务器端开放 5678 端口，客户端在建立完连接后，服务器端给客户端发送信息，客户端接收信息并输出。</p>
<h3 id="服务器端-2">服务器端：</h3>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;

#define MAXLINE 128

class Socks5Server {
public:
    Socks5Server();
    ~Socks5Server();
    int open_listenfd();
    int listen_client();
    void recv_mes();
    void send_mes(int fd, const char* str);

private:
    int _fd; // 主 fd
    char _buf[MAXLINE + 1];
};

Socks5Server::Socks5Server() {
    _fd = -1;
}

Socks5Server::~Socks5Server() {
    if (_fd &gt; 0) {
        close(_fd);
    }
}

int Socks5Server::open_listenfd() {
    // 成功，返回0；失败，返回-1
    /*
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
    服务器用来绑定本地端点地址（创建 主套接字），用 getaddrinfo 自动生成参数配合使用
    OK(0)，error(-1)
    */
    struct addrinfo *p, *lisp, hints;
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM; // TCP 会建立连接
    hints.ai_flags = AI_ADDRCONFIG | AI_PASSIVE;
    hints.ai_flags |= AI_NUMERICSERV;
    /*
    hint.ai_flags 需要修改：
    AI_ADDRCONFIG：在使用连接时设置这个。
    AI_CANONNAME：ai_canonname 默认为 NULL。设置这个标志后，将链表里第一个结构的 ai_canonname 指向主机的？？？
    AI_NUMERICSERV：原本 getaddrinfo 第二个参数，可以为服务名或端口号，设置后强制为端口号。
    AI_PASSIVE：返回的套接字地址为服务器监听套接字。此时 hostname 为 NULL
    */
    int err = getaddrinfo(NULL, &quot;5678&quot;, &amp;hints, &amp;lisp);
    if (err != 0) {
        printf(&quot;getaddrinfo error：%s\n&quot;, gai_strerror(err));
    }
    p = lisp;
    int optval = 1;
    for (p = lisp; p; p = p-&gt;ai_next) {
        _fd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (_fd &lt; 0) continue; // 看链表中下一个结构体
        /*
        在 TCP 连接中，recv 等函数默认为阻塞模式(block)，即直到有数据到来之前函数不会返回，而我们有时则需要一种超时机制，使其在一定时间后返回，而不管是否有数据到来，这里我们就会用到：
        int  setsockopt(int fd, int level, int optname, void* optval, socklen_t* optlen);
        */
        setsockopt(_fd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;optval , sizeof(int));
        // bind 服务器用来绑定本地端点地址（创建 主套接字）
        err = bind(_fd, p-&gt;ai_addr, p-&gt;ai_addrlen);
        if (err == 0) { // 绑定成功
            if ((err = listen(_fd, 1024)) == -1) {
                printf(&quot;transfer error\n&quot;);
                close(_fd);
                //return -1;
            } else {
                //printf(&quot;_fd: %d\n&quot;, _fd);
                break; // 成功建立连接
            }
        }
    }
    freeaddrinfo(lisp);
    if (p == NULL) {
        printf(&quot;no addr\n&quot;);
        return -1; // 失败
    }
    else return 0; // 成功
}

int Socks5Server::listen_client() {
    /*
    int accept(int listenfd, struct sockaddr *addr, int *addrlen);
    只用于TCP，会创建一个新的套接字（和客户端关联起来了的套接字），使用这个新的套接字和客户端进行通信，用于并发。本函数会阻塞等待直到有客户端请求到达。
        addr：存放客户端的地址
        addrlen：在调用函数时被设置为 addr 指向区域的长度，在函数调用结束后被设置为实际地址信息的长度
    返回值：OK(新的 fd )，error(-1)
    */
    int new_fd;
    //struct sockaddr clientaddr;
    char clientaddr[1000];
    //socklen_t clientlen = sizeof(clientaddr);
    socklen_t clientlen = 1000;
    // 本函数会阻塞等待直到有客户端请求到达。
    new_fd = accept(_fd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);
    //printf(&quot;new_fd : %d\n&quot;, new_fd);
    //printf(&quot;%s\n&quot;,strerror(new_fd));
    return new_fd;
}

void Socks5Server::recv_mes() {
    /*
    int recv( int fd, char *buf, int len, int flags);
    客户端或服务器，接收数据。
        fd：接收端套接字描述符；
        buf：缓冲区，该缓冲区用来存放 recv 函数接收到的数据
        len：buf 的长度
        flags：一般置 0
    失败时，返回值小于0；超时或对端主动关闭，返回值等于0；成功时，返回值是返回接收数据的长度
    */
    int ret;
    while ((ret = recv(_fd, _buf, MAXLINE, 0)) &gt; 0) {
        // 成功时，返回字符串长度
        _buf[ret] = '\0';
        printf(&quot;%s\n&quot;, _buf);
    }
}

void Socks5Server::send_mes(int fd, const char* str) {
    /*
    int send(int fd, const char *buf, int len, int flags);
        参数一：指定发送端套接字描述符；
        参数二：指明一个存放应用程序要发送数据的缓冲区；
        参数三：指明实际要发送的数据的字节数；
        参数四：一般置0；
    返回值：失败时，返回值小于0；超时或对端主动关闭，返回值等于0；成功时，返回值是返回发送数据的长度。
    */
    send(fd, str, strlen(str), 0);
}

int main() {
    Socks5Server s;
    int ret = s.open_listenfd();
    if (ret &lt; 0) {
        printf(&quot;open_main_fd error\n&quot;);
    } else {
        printf(&quot;open_main_fd success\n&quot;);
        int tt = 3;
        while (tt--) {
            int new_fd = s.listen_client();
            if (new_fd == -1) {
                printf(&quot;new_fd error\n&quot;);
            } else {
                printf(&quot;new_fd success : %d\n&quot;, new_fd);
            }
            s.send_mes(new_fd, &quot;hello\n&quot;);
            close(new_fd);
        }
    }
    return 0;
}
</code></pre>
<h3 id="客户端-2">客户端：</h3>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;


#define DONAME &quot;xx&quot; // 32位点分十进制 ip，这里我改掉了
#define MAXLINE 128

class Socks5Client {
public:
    Socks5Client(const char* hostname, const char* port);
    ~Socks5Client();
    int open_clientfd();
    void recv_mes();

private:
    int _fd;
    char _hostname[MAXLINE + 1];
    char _port[MAXLINE + 1];
    char _buf[MAXLINE + 1];
};

Socks5Client::Socks5Client(const char* hostname, const char* port) {
    _fd = -1;
    int len = strlen(hostname);
    if (len &lt;= MAXLINE) {
        memcpy(_hostname, hostname, len);
        _hostname[len] = '\0';
        //printf(&quot;hostname : %s\n&quot;, _hostname);
    }
    len = strlen(port);
    if (len &lt;= MAXLINE) {
        memcpy(_port, port, len);
        _port[len] = '\0';
        //printf(&quot;_port : %s\n&quot;, _port);
    }
}

Socks5Client::~Socks5Client() {
    if (_fd &gt; 0) {
        close(_fd);
    }
}

int Socks5Client::open_clientfd() {
    // 成功 返回 0
    // 失败，返回 -1
    struct addrinfo *p, *lisp, hints;
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM; // TCP 会建立连接
    // AI_ADDRCONFIG：在使用连接时设置这个。
    // AI_NUMERICSERV：不可为服务名，强制为端口号。
    //hints.ai_flags = AI_ADDRCONFIG | AI_NUMERICSERV;
    hints.ai_flags = AI_ADDRCONFIG;
    int err = getaddrinfo(_hostname, _port, &amp;hints, &amp;lisp);
    //printf(&quot;hostname: %s port: %s\n&quot;, _hostname, _port);

    if (err != 0) {
        printf(&quot;getaddrinfo error：%s\n&quot;, gai_strerror(err));
    }

    p = lisp;
    for (p = lisp; p; p = p-&gt;ai_next) {
        //printf(&quot;p: %d\n&quot;, p);
        _fd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        //printf(&quot;fd : %d\n&quot;, _fd);
        if (_fd &lt; 0) {
            printf(&quot;error fd : %d\n&quot;, _fd);
            continue; // 看链表中下一个结构体
        }
        /*
        int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);
        客户端用来建立和服务器的连接（指定S端点地址），返回值：OK(0)，error(-1)
        */
        err = connect(_fd, p-&gt;ai_addr, p-&gt;ai_addrlen);

        if (err == 0) {
            printf(&quot;connect success\n&quot;);
            break; // 成功建立连接
        } else {
            perror(&quot;connect error: &quot;);
            close(_fd); // 建立连接失败
        }
    }

    freeaddrinfo(lisp);
    if (p == NULL) {
        printf(&quot;no addr\n&quot;);
        return -1; // 失败
    } else return 0; // 成功
}
/*
int getaddrinfo(const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result);
    主机名、主机地址、服务名、端口号的字符串表示 -&gt; 套接字
    返回值：OK(0), error(非0)

    参数：
    hostname：主机名或地址串(IPv4的点分十进制串或者 IPv6的16进制串)
    service：十进制的端口号，或是已定义的服务名称，如ftp、http等

    hints：空指针，或是一个指向某个 addrinfo 结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。
    举例来说：如果指定的服务既支持 TCP 也支持 UDP，那么调用者可以把 hints 结构中的 ai_socktype 成员设置成 SOCK_DGRAM 使得返回的仅仅是适用于数据报套接口的信息。
    必须先分配一个 hints 结构，把它清零后填写需要的字段

    result：一个指向 addrinfo 结构体链表的指针。用于后续的 socket 函数。默认最多返回 3 个 addrinfo 结构。调用 getaddrinfo 后遍历链表，逐个尝试每个返回地址。

hints 和 result 的结构：
struct addrinfo {
    int ai_flags;    // Hints argument flags
    int ai_family;   // AF_INET（ipv4）或 AF_INET6（ipv6）
    int ai_socktype; // SOCK_STREAM（TCP流）或 SOCK_DGRAM（UDP数据报）
    int ai_protocol; // 一般为 0 不做修改
    char *ai_canonname; // Canonical hostname
    size_t ai_addrlen;  //Size of ai_addr struct
    struct sockaddr *ai_addr; // Ptr to socket address structure
    struct addrinfo *ai_next; // Ptr to next item in linked list
};

ai_flags：可以把各种值用 OR 组合起来得到该掩码。

用完必须释放：
void freeaddrinfo(struct addrinfo *res);
    res 参数指向链表中第一个 addrinfo 结构。这个链表中的所有结构以及它们指向的任何动态存储空间都被释放掉。


const char *gai_strerror(int error);
    打印错误信息：该函数以 getaddrinfo 返回的非 0 错误值的名字和含义为他的唯一参数，返回一个指向对应的出错信息串的指针。
*/

void Socks5Client::recv_mes() {
    int ret;

    while ((ret = recv(_fd, _buf, MAXLINE, 0)) &gt; 0) {
        printf(&quot;recv success\n&quot;);
        // 成功时，返回字符串长度
        _buf[ret] = '\0';
        printf(&quot;str: %s\n&quot;, _buf);
        //ret = recv(_fd, _buf, MAXLINE, 0);
    }
}

int main() {
    Socks5Client c(DONAME, &quot;5678&quot;);
    int ret = c.open_clientfd();
    if (ret &lt; 0) {
        printf(&quot;open_clientfd error\n&quot;);
    } else {
        printf(&quot;open_clientfd success\n&quot;);
        c.recv_mes();
    }
    return 0;
}

</code></pre>
<h2 id="并发编程">并发编程</h2>
<h3 id="1-每次-accept-都在-fork-的子进程里实现">1、每次 accept 都在 fork 的子进程里实现</h3>
<p>略微修改服务器端的代码即可：</p>
<pre><code>void sigchld_handler(int sig) {
    while (waitpid(-1, 0, WNOHANG) &gt; 0) {
        /*
        回收子进程，回收成功一个，返回子进程的pid
        WNOHANG：非阻塞。如果有子进程,但没有结束(没有变僵尸进程)，waitpid 返回 0，退出 while
        如果有僵尸进程，回收一个僵尸进程，返回僵尸进程 pid，所以要用循环去处理，把僵尸进程回收完
        */
        ;
    }
    //printf(&quot;wait end\n&quot;);
}

int Socks5Server::listen_client() {
    signal(SIGCHLD, sigchld_handler);
    printf(&quot;listening=========== main fd : %d\n&quot;, _fd);

    int new_fd, num = 0;
    char clientaddr[1000];
    socklen_t clientlen = 1000;

    while(1) {
        // 本函数会阻塞等待直到有客户端请求到达。
        new_fd = accept(_fd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);
        //printf(&quot;new_fd : %d\n&quot;, new_fd);
        num++;

        if (fork() == 0) {
            // 子进程
            close(_fd);
            if (new_fd == -1) {
                printf(&quot;new_fd error\n&quot;);
            } else {
                printf(&quot;【child】new_fd success : %d\n&quot;, new_fd);
            }
            send_mes(new_fd, &quot;hello\n&quot;);
            printf(&quot;num : %d\n&quot;, num);

            close(new_fd);
            //printf(&quot;【child】close new_fd : %d\n&quot;, new_fd);
            exit(0); // 子进程直接退出，父进程会重新进入循环
        } else {
            // 父进程
            //printf(&quot;【father】close new_fd : %d\n&quot;, new_fd);
            close(new_fd);
        }

    }
    return new_fd;
}

int main() {
    Socks5Server s;
    int ret = s.open_listenfd();
    if (ret &lt; 0) {
        printf(&quot;open_main_fd error\n&quot;);
    } else {
        printf(&quot;open_main_fd success\n&quot;);
        s.listen_client();
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux下vim的便捷使用]]></title>
        <id>https://ccccj.github.io/linux-xia-vim-de-bian-jie-shi-yong/</id>
        <link href="https://ccccj.github.io/linux-xia-vim-de-bian-jie-shi-yong/">
        </link>
        <updated>2019-08-23T18:24:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本篇较多的都是关于 vim 的快捷使用，另外夹杂着一些我觉得好用的技巧。</p>
</blockquote>
<h3 id="1快捷键设置">1.快捷键设置</h3>
<p>举个栗子，例如每次在vim中敲完代码，退出vim再编译链接有点麻烦，可以用快捷键替换来实现写完代码立即运行</p>
<blockquote>
<p><code>nnoremap &lt;F5&gt; :!gcc -o a.out % &amp;&amp; ./a.out&lt;CR&gt;</code></p>
</blockquote>
<p>写到vim配置文件 (~/.vimrc) 中即可。<br>
如果没有，可以自己创建一个，但是创建之后，会缺少一些基本配置，因为默认的配置文件是 /etc/vimrc ，里面有一些原本的功能，有了 ~/.vimrc 后，系统会使用这个，所以配置时，建议其他功能一起配置。</p>
<p>这其实是一条映射，也就是把<code>&lt;F5&gt;</code>映射成后面一长条语句，当按下F5，就相当于执行了那一条语句。</p>
<p><code>nnoremap</code> 表示生效范围</p>
<blockquote>
<p>1.第一个 n 代表<code>普通模式</code>，如果要在插入模式下实行替换，可以用 <code>i</code> ，可视模式为 <code>v</code>；<br>
2.<code>nore</code>表示不递归，看网上说大概是大概是 no recursion..？如果不加 nore，将会递归替换，大多数时候容易造成混乱。</p>
</blockquote>
<p><code>&lt;F5&gt;</code>  表示按下F5键；<br>
<code>:</code>  进入命令行模式；<br>
<code>!</code>  在vim的命令行模式下用shell的命令；<br>
<code>!gcc -o a.out %</code>  %代表当前文件名，gcc -o a.out % 即为编译链接当前文件，生成 a.out；<br>
<code>&amp;&amp;</code>  表示同时执行两条命令<br>
<code>./a.out</code>  运行当前目录下的a.out文件<br>
<code>&lt;CR&gt;</code>  回车即&quot;enter&quot;键（也可小写）</p>
<blockquote>
<p>定义组合键时，例如 <code>ctrl + w</code>，配置时为 <code>&lt;c-w&gt;</code>;<br>
<code>alt + w</code> 时， 配置为 <code>&lt;m-w&gt;</code><br>
(w为任意键)</p>
</blockquote>
<p>如果还没学会这个，那我们再来看一条（这个就不算快捷键了，只是简单的替换而已）：</p>
<blockquote>
<p><code>inoremap ( ()&lt;esc&gt;i</code></p>
</blockquote>
<p>即在插入模式下，输入<code>(</code>，就会自动变为输入<code>()&lt;esc&gt;i</code>，为什么输入 () 不够，还要推出回到普通模式再输入 i 呢？因为这样，光标就会移动到括号中间，方便输入啦。现在学会了没有呢？</p>
<p>（后面第九条还有更多的 vim 的配置，这条为啥单独写这呢..我也不知道...可能是因为这个在我看来属于自己设置快捷键，你想实现什么功能就实现什么功能，可以设置单独的键，而后面的只能算配置自己的 vim 吧）</p>
<p>！！敲黑板：这个设置完真的是超级方便。</p>
<h3 id="2设置书签">2.设置书签</h3>
<p>在某一行，按下m，再按某个字母，例如'a'，表示在这一行设置了名为a的书签，当要查找这个书签时，按下单引号，再按下书签名即可。</p>
<blockquote>
<p>设置书签:<code>mx</code> //x代表任意字母<br>
查找书签:<code>'x</code> //x代表设置书签时选择的任意字母</p>
</blockquote>
<p>同时还可以设置很多字母，设置很多个书签。。。有时候写代码，函数与测试文件分开时，需要写一个函数测试一下，那在函数与测试代码之间就需要跳来跳去，用书签就很方便。</p>
<p>总体来说，写较长的代码，并且需要来回切换的时候比较方便吧，但是也可以直接开两个窗口（我屏幕小，还是喜欢跳来跳去...）</p>
<h3 id="3打开标签页">3.打开标签页</h3>
<p>就像我们的网页，同时开启多个上面会有多个标签页，vim 也能这样：</p>
<blockquote>
<p><code>:tabe xxx</code></p>
</blockquote>
<p>xxx 为文件名，也可以加上路径，使得可以同时打开多个文件。</p>
<blockquote>
<p><code>gt</code> 切换到下一个标签页<br>
<code>gT</code> 切换到上一个标签页<br>
<code>:q</code> 关闭当前标签页</p>
</blockquote>
<p>这个我倒是不常用..可能是因为我一般代码就开一两个窗口而已，最多也就三个，所以打开 vim 的时候我就会直接打开两个，然后用 <code>:bn</code> 来切换，但是什么时候我会用到呢，一般写着写着，突然发现要看下以前某个文件，我就会用标签页的方式打开（当然你也可以直接新开个窗口）。</p>
<h3 id="4快捷缩进与注释">4.快捷缩进与注释</h3>
<p>[单行快捷缩进]</p>
<blockquote>
<p><code>按“&gt;&gt;”或“&lt;&lt;”</code>(向右缩进/向左缩进)<br>
无需选中本行，光标在这一行即可，按两下 <code>shift+</code> , 或两下 <code>shift+.</code> 即可。</p>
</blockquote>
<p>[快捷缩进]</p>
<blockquote>
<p>进入可视块模式后，选中每行第一个字母，按<br>
<code>&quot;&lt;&quot;</code> (shift+,) 向左缩进<br>
<code>&quot;&gt;&quot;</code> (shift+.) 向右缩进</p>
</blockquote>
<p>[快捷注释]</p>
<blockquote>
<p>进入可视块模式，选中注释的行开头，按 <code>shift+i/I</code>（即在行首插入） ，再按<code>//</code>，再按两下<code>esc</code></p>
</blockquote>
<p>[取消注释]</p>
<blockquote>
<p>可视块模式选中所有的<code>//</code>，再按<code>d(或x)</code>删除</p>
</blockquote>
<p>总结：常用，非常好用。</p>
<h3 id="5vim的粘贴格式">5.vim的粘贴格式</h3>
<p>很多时候可能复制了一段代码，要粘贴到vim里。然后就发现，啊这格式咋不了啊，多出来辣么多空格是咋回事...<br>
就是格式的问题...<br>
输入<code>:set paste</code> ，就可以解决格式问题，而只是简单的粘贴文本。<br>
记得粘贴完成后退出 <code>set no paste</code>。</p>
<p>emmmmm，很好记，要用到的时候能记住就好了，不然会发现粘贴格式很乱。</p>
<h3 id="6vim内快捷查找">6.vim内快捷查找</h3>
<blockquote>
<p><code>:/xxx</code>  查找“xxx”这个词<br>
[按n查找下一个 N查找上一个]<br>
[如果输入完 <code>:/xxx</code>后，再按<code>*</code>，即完全匹配查找（如果你查找的是 a，有个词叫 aa ，这时候查找结果不会有 aa ）]<br>
<code>?xxx</code><br>
[不需要冒号，也是查找 xxx 这个词，但是和  :/xxx 方向相反]<br>
<code>:n</code>     到第n行</p>
</blockquote>
<p>不记住这个的话...还用什么 vim ...</p>
<h3 id="7快捷替换">7.快捷替换</h3>
<blockquote>
<p><code>:%s/word1/word2</code><br>
[把当前行第一个word1替换为word2]<br>
<code>:n1,n2 s/word1/word2/gc</code><br>
[n1行到n2行，把word1都替换为word2，有c会一个个询问是否替换]<br>
[如果只有<code>/g</code>，就不会询问，直接全部替换]</p>
</blockquote>
<p>这个有时候超级方便，我有时候用别的编辑器比如 word 什么的，也超希望能有这个功能...用过 n 多次，但是永远记不住..每次要用就打开自己这篇博客来看下...</p>
<h3 id="8vim内置分屏">8.vim内置分屏</h3>
<p>依靠命令行模式来进行分屏，写代码时如果和前面有段代码要比对这些，但是又看不到前面的，就可以这么干（当然你也可以再打开个窗口啦，只是有时候分屏比较方便，虽然很多终端也自带分屏功能..）</p>
<blockquote>
<p><code>:vs</code> 水平分屏（后面+空格+文件名，可以打开指定文件来分屏）<br>
<code>ctrl+w</code> 再移动光标，会在分屏幕模式下，左右移动光标</p>
</blockquote>
<hr>
<blockquote>
<p><code>:sp</code> 垂直分屏<br>
<code>ctrl+g</code> 再移动光标，会在分屏幕模式下，上下移动光标</p>
</blockquote>
<hr>
<blockquote>
<p><code>:q</code> 退出当前分屏窗口<br>
<code>:qa</code> 退出当前所有分屏窗口</p>
</blockquote>
<p>可以将这些组合键设置成快捷键，更方便~<br>
（但是悄咪咪的说一句..我一般直接再开个屏..因为我蠢记不住..）</p>
<h3 id="9vim的基本配置">9.vim的基本配置</h3>
<p>vim ~/.vimrc 修改配置文件<br>
（加个 <code>.</code> 代表隐藏文件）</p>
<pre><code>syntax on &quot; 语法高亮
set hlsearch  &quot; 设置搜索结果高亮 highlight search
set number &quot; 显示行号
set tabstop=4 &quot; Tab代表4个空格的宽度（我一般用2个）
set autoindent &quot; 表示换行后自动缩进
set history=1000 &quot; 记住的历史操作的数量，默认的是20
set mouse=a &quot; 可以使用鼠标
&quot;set mouse-=a &quot; 不可使用鼠标

&quot; 括号匹配
inoremap ( ()&lt;ESC&gt;i
inoremap { {&lt;CR&gt;}&lt;ESC&gt;O
inoremap [ []&lt;ESC&gt;i
inoremap &quot; &quot;&quot;&lt;ESC&gt;i
inoremap ' ''&lt;ESC&gt;i

&quot; inoremap jk &lt;ESC&gt; &quot; jk退出

&quot; 检测下一个是不是右括号，是的话自动覆盖（摘自百度）
inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt;
inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt;
inoremap } &lt;c-r&gt;=CloseBracket()&lt;CR&gt;
inoremap &quot; &lt;c-r&gt;=QuoteDelim('&quot;')&lt;CR&gt;
inoremap ' &lt;c-r&gt;=QuoteDelim(&quot;'&quot;)&lt;CR&gt;

function ClosePair(char)
	if getline('.')[col('.') - 1] == a:char
		return &quot;\&lt;Right&gt;&quot;
	else
		return a:char
	endif
endf

function CloseBracket()
	if match(getline(line('.') + 1), '\s*}') &lt; 0
		return &quot;\&lt;CR&gt;}&quot;
	else
		return &quot;\&lt;Esc&gt;j0f}a&quot;
	endif
endf

function QuoteDelim(char)
	let line = getline('.')
	let col = col('.')
	if line[col - 2] == &quot;\\&quot;
		return a:char
	elseif line[col - 1] == a:char
		return &quot;\&lt;Right&gt;&quot;
	else
		return a:char.a:char.&quot;\&lt;Esc&gt;i&quot;
	endif
endf
</code></pre>
<p>关于这一块的配置..本来是只写了这么点，其余的希望大家自己直接上网搜的，因为我自己写的一些配置，可能不是很好，怕误导了大家。但是写完这篇博客后的几个月的今天..还是忍不住给大家分享几条我的配置，由于是自己写的，也借阅网上的配置，所以写的我自己都觉得不太好...</p>
<blockquote>
<p><code>nnoremap ii i&lt;TAB&gt;</code></p>
</blockquote>
<p>这个就是，大家有没有发现..有时候敲代码，光标在行首，按了个 <code>i</code> ，光标还是在行首，但是我想要直接写代码滴呀，我要缩进啊，于是就设置个快捷键..按两下 i ，就直接进入插入模式，并且前面有缩进，真的超级方便..</p>
<blockquote>
<p><code>nnoremap qq &lt;esc&gt;A</code></p>
</blockquote>
<p>有时候正在输入，但是想立马到行尾，就可以这样实现<sub>先回到普通模式，再插入到行尾</sub></p>
<p>其余的我想到再补充~~</p>
<h3 id="10vim内使用shell命令行">10.vim内使用shell命令行</h3>
<p>有时候需要在 vim 内使用 shell 的命令（例如要编译执行当前代码），当然可以立马新开一个窗口，或者像之前讲过的那样设置快捷键，但是现在要讲的是另一种方法：</p>
<blockquote>
<p><code>:!xxx</code></p>
</blockquote>
<p>即先进入 vim 的命令行模式，在按下 <code>!</code> ，这时候的目录是你当前文件的目录，然后就可以输入命令了，例如有时候，需要编译执行当前文件，就可以直接这么用。</p>
<p>是的..你用再开个窗口大法也可以，但是我还是会经常用这个的，因为方便啊，再开个窗口还要移动光标，这个直接按个 <code>:</code> 就好啦。</p>
<h3 id="11按键使用">11.按键使用</h3>
<p>总结了一些vim下常用的按键，已经熟练使用vim的请跳过本条....</p>
<p>（所有的大写建议 shift+.. 来使用）</p>
<p>（1）一般模式下<br>
移动光标：<br>
(前面加数字，可以一下子跳很多格)</p>
<blockquote>
<p>左：<code>h</code>；<br>
下：<code>j</code>；<br>
上：<code>k</code>；<br>
右：<code>l</code>；</p>
</blockquote>
<hr>
<blockquote>
<p><code>b</code>：移到前一个单词开头<br>
<code>w</code>：移到后一个单词开头<br>
<code>e</code>：移到后一个单词末尾<br>
<code>gg</code>：移到首行开头<br>
<code>shift+g</code>/<code>G</code>：移到末行开头<br>
<code>0</code>(零)：移到当前行开头<br>
<code>^</code>：移动到行首非空白字符<br>
<code>$</code>：移到当前行行尾<br>
<code>[]</code>：跳转到上一个函数<br>
<code>][</code>：跳转到下一个函数</p>
</blockquote>
<p>模式转换：</p>
<blockquote>
<p><code>i</code>：进入插入模式(写在光标之前)<br>
<code>a</code>：进入插入模式(写在光标之后)<br>
<code>shift+i</code>/<code>I</code>：进入插入模式(写在行首)<br>
<code>shift+a</code>/<code>A</code>：进入插入模式(写在行尾)<br>
<code>o</code>(字母o)：到下一行，插入空行，并进入插入模式<br>
<code>shift+o</code>/<code>O</code>(大写O)：到上一行，插入空行，并进入插入模式</p>
</blockquote>
<blockquote>
<p><code>esc</code>：退出插入模式，回到命令模式<br>
<code>:</code>(冒号)：到命令行模式</p>
</blockquote>
<p>复制粘贴删除：</p>
<blockquote>
<p><code>yy</code>(或<code>Y</code>)：复制一行（3yy为复制3行）<br>
<code>p</code>：粘贴<br>
<code>dd</code>：删除一行（5dd为删除5行）<br>
<code>x</code>：删除一个字符（3x删除后面3个字符）<br>
<code>dw</code>：从当前光标开始，删除到单词结束<br>
<code>d$</code>：从当前光标开始，删除到行尾<br>
<code>r</code>：替换<br>
<code>shift+r</code>/<code>R</code>：行替换</p>
</blockquote>
<p>可视模式：</p>
<blockquote>
<p><code>v</code>：可视模式<br>
<code>ctrl+v</code>：可视块模式<br>
<code>shift+v</code>/<code>V</code>：可视行模式</p>
</blockquote>
<p>撤销：</p>
<blockquote>
<p><code>u</code>：撤销<br>
<code>ctrl+r</code>：取消撤销</p>
</blockquote>
<p>（2）命令行模式中：</p>
<p>保存与退出</p>
<blockquote>
<p><code>:w</code> 保存<br>
<code>:q</code> 退出 （:qw  保存并退出  :q! 不保存退出）</p>
</blockquote>
<p>其他：</p>
<blockquote>
<p><code>:set nu</code> 设置行号  （set nonu 取消行号）<br>
<code>:set mouse=a</code> 设置可以使用鼠标<br>
<code>:set mouse-=a</code> 设置不能使用鼠标</p>
</blockquote>
<hr>
<blockquote>
<p>普通模式下， 将光标放在<code>(</code>/<code>[</code>/<code>{</code>上，按下<code>%</code>，光标将会跳到下一个匹配的<code>)</code>/<code>]</code>/<code>}</code>，再次按<code>%</code>，将会跳回去。（可用于调试时查看括号配对）</p>
</blockquote>
<p>更具体的可以看 <code>vimtutor</code>(直接在bash输入即可)</p>
<h3 id="12学会查找">12.学会查找</h3>
<p>按文件名查找：<br>
<code>find -name &lt;filename&gt;</code><br>
这是一个最简单的查找命令，按名字查找当前目录下的文件，查找结果会显示路径。</p>
<p>按文件内容查找：<br>
<code>grep xxx &lt;directory&gt;</code><br>
&quot;xxx&quot; 是你要查找的字符串，<directory>是要查找的目录。当然我们还可以添加选项，如<code>-n</code>显示行号，<code>-i</code>查找时忽略大小写，<code>-v</code>反向查找。其他还可以搭配管道等等应用，但最简单的应用</p>
<h3 id="参考">参考</h3>
<p>https://blog.csdn.net/sunlanchang/article/details/52549756</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python学习笔记]]></title>
        <id>https://ccccj.github.io/python-xue-xi-bi-ji/</id>
        <link href="https://ccccj.github.io/python-xue-xi-bi-ji/">
        </link>
        <updated>2019-05-03T18:37:27.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%BC%A9%E8%BF%9B">1.注释与缩进</a>
<ul>
<li><a href="#11-%E6%B3%A8%E9%87%8A">1.1 注释</a></li>
<li><a href="#12-%E7%BC%A9%E8%BF%9B%E8%A7%84%E5%88%99">1.2 缩进规则</a></li>
</ul>
</li>
<li><a href="#2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.数据类型</a>
<ul>
<li><a href="#21-%E6%95%B4%E5%9E%8B">2.1 整型</a></li>
<li><a href="#22-%E6%B5%AE%E7%82%B9%E5%9E%8B">2.2 浮点型</a></li>
<li><a href="#23-%E5%AD%97%E7%AC%A6%E4%B8%B2">2.3 字符串</a>
<ul>
<li><a href="#231-%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E5%92%8C">2.3.1 内部使用<code>'</code>和<code>&quot;</code></a></li>
<li><a href="#232-%E8%BD%AC%E4%B9%89">2.3.2 转义</a></li>
<li><a href="#233-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">2.3.3 字符串拼接</a></li>
<li><a href="#234-%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6">2.3.4 中文字符</a></li>
</ul>
</li>
<li><a href="#24-%E5%B8%83%E5%B0%94%E5%80%BC">2.4 布尔值</a>
<ul>
<li><a href="#241-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.4.1 基本概念</a></li>
<li><a href="#242-%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97">2.4.2 短路运算</a></li>
</ul>
</li>
<li><a href="#25-%E7%A9%BA%E5%80%BC">2.5 空值</a></li>
</ul>
</li>
<li><a href="#3%E5%8F%98%E9%87%8F">3.变量</a>
<ul>
<li><a href="#31-%E5%8F%98%E9%87%8F%E5%90%8D">3.1 变量名</a></li>
<li><a href="#32-%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80">3.2 动态语言</a></li>
<li><a href="#32-%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90">3.2 具体分析</a></li>
</ul>
</li>
<li><a href="#4list-tuple-%E7%B1%BB%E5%9E%8B">4.list / tuple 类型</a>
<ul>
<li><a href="#41-list">4.1 list</a>
<ul>
<li><a href="#411-%E6%9E%84%E9%80%A0">4.1.1 构造</a></li>
<li><a href="#412-%E4%BD%BF%E7%94%A8">4.1.2 使用</a></li>
<li><a href="#413-%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0">4.1.3 添加新元素</a></li>
<li><a href="#414-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">4.1.4 删除元素</a></li>
<li><a href="#415-%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0">4.1.5 替换元素</a></li>
</ul>
</li>
<li><a href="#42-tuple">4.2 tuple</a>
<ul>
<li><a href="#421-%E6%9E%84%E9%80%A0">4.2.1 构造</a></li>
<li><a href="#422-%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84tuple">4.2.2 单元素的tuple</a></li>
<li><a href="#423-%E5%8F%AF%E5%8F%98tuple">4.2.3 可变tuple</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF">5.条件判断与循环</a>
<ul>
<li><a href="#51-if">5.1 if</a></li>
<li><a href="#52-if-else">5.2 if-else</a></li>
<li><a href="#53-if-elif-else">5.3 if-elif-else</a></li>
<li><a href="#54-for%E5%BE%AA%E7%8E%AF">5.4 for循环</a></li>
<li><a href="#55-while%E5%BE%AA%E7%8E%AF">5.5 while循环</a></li>
<li><a href="#56-break%E4%B8%8Econtinue">5.6 break与continue</a>
<ul>
<li><a href="#561-break">5.6.1 break</a></li>
<li><a href="#562-continue">5.6.2 continue</a></li>
</ul>
</li>
<li><a href="#57-%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF">5.7 多重循环</a></li>
</ul>
</li>
<li><a href="#6-dict-%E5%92%8C-set-%E7%B1%BB%E5%9E%8B">6 dict 和 set 类型</a>
<ul>
<li><a href="#61-dict">6.1 dict</a>
<ul>
<li><a href="#611-%E6%9E%84%E9%80%A0">6.1.1 构造</a></li>
<li><a href="#612-%E4%BD%BF%E7%94%A8">6.1.2 使用</a></li>
<li><a href="#613-dict%E7%9A%84%E7%89%B9%E7%82%B9">6.1.3 dict的特点</a></li>
<li><a href="#614-%E6%9B%B4%E6%96%B0dict">6.1.4 更新dict</a></li>
<li><a href="#615-%E9%81%8D%E5%8E%86dict">6.1.5 遍历dict</a></li>
</ul>
</li>
<li><a href="#62-set">6.2 set</a>
<ul>
<li><a href="#621-%E6%9E%84%E9%80%A0">6.2.1 构造</a></li>
<li><a href="#622-%E4%BD%BF%E7%94%A8">6.2.2 使用</a></li>
<li><a href="#623-set-%E7%9A%84%E7%89%B9%E7%82%B9">6.2.3 set 的特点</a></li>
<li><a href="#624-%E9%81%8D%E5%8E%86-set">6.2.4 遍历 set</a></li>
<li><a href="#625-%E6%9B%B4%E6%96%B0-set">6.2.5 更新 set</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7%E5%87%BD%E6%95%B0">7.函数</a>
<ul>
<li><a href="#71-python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">7.1 python内置函数</a></li>
<li><a href="#72-%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0">7.2 编写函数</a></li>
<li><a href="#73-%E8%BF%94%E5%9B%9E%E5%A4%9A%E5%80%BC">7.3 返回多值</a></li>
<li><a href="#74-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">7.4 默认参数</a></li>
<li><a href="#75-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">7.5 可变参数</a></li>
</ul>
</li>
<li><a href="#8%E5%88%87%E7%89%87">8.切片</a>
<ul>
<li><a href="#81-%E5%88%87%E7%89%87%E7%AE%80%E8%BF%B0">8.1 切片简述</a></li>
<li><a href="#82-%E5%80%92%E5%BA%8F%E5%88%87%E7%89%87">8.2 倒序切片</a></li>
<li><a href="#83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87">8.3 字符串切片</a></li>
</ul>
</li>
<li><a href="#9%E8%BF%AD%E4%BB%A3">9.迭代</a>
<ul>
<li><a href="#91-%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%A6%82%E5%BF%B5">9.1 迭代的概念</a></li>
<li><a href="#92-%E7%B4%A2%E5%BC%95%E8%BF%AD%E4%BB%A3">9.2 索引迭代</a></li>
<li><a href="#93-%E8%BF%AD%E4%BB%A3dict">9.3 迭代dict</a></li>
</ul>
</li>
<li><a href="#10%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F">10.列表生成式</a>
<ul>
<li><a href="#101-%E7%AE%80%E8%BF%B0">10.1 简述</a></li>
<li><a href="#102-%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97">10.2 多层嵌套</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="1注释与缩进">1.注释与缩进</h2>
<h3 id="11-注释">1.1 注释</h3>
<p>以 <code>#</code> 开头，一直到行尾。</p>
<h3 id="12-缩进规则">1.2 缩进规则</h3>
<p>python中，具有相同缩进的代码被视为代码块。<br>
Python的习惯写法：4个空格，不使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。</p>
<h2 id="2数据类型">2.数据类型</h2>
<h3 id="21-整型">2.1 整型</h3>
<p>16 进制 用 0x 作为前缀。<br>
过大数据可用 e 代表 10 的次方，如 1e3 代表 1000 。</p>
<h3 id="22-浮点型">2.2 浮点型</h3>
<p>依然可用 e 代表 10 的次方，如 1e-3 代表 0.001 。</p>
<h3 id="23-字符串">2.3 字符串</h3>
<p>以<code>' '</code>、<code>&quot; &quot;</code>或<code>''' '''</code>括起来的任意文本。若使用多行文字，用<code>''' '''</code>。</p>
<pre><code class="language-py">print 'hello\nworld'
print '''hello
world'''
</code></pre>
<blockquote>
<p>hello<br>
world<br>
hello<br>
world</p>
</blockquote>
<h4 id="231-内部使用和">2.3.1 内部使用<code>'</code>和<code>&quot;</code></h4>
<p>若 想要在字符串内部加上这些符号，可这样用：</p>
<pre><code class="language-py">print &quot;'hello'&quot;
print '&quot;hello&quot;'
</code></pre>
<pre><code>'hello'
&quot;hello&quot;
</code></pre>
<p>即，若字符串内部包含<code>'</code>，那我们用<code>&quot;&quot;</code>括起字符串，若字符串内部包含<code>&quot;</code>，那我们用<code>''</code>括起字符串。<br>
若既有<code>'</code>又有<code>&quot;</code>呢？可以使用<code>\</code>转义。</p>
<p>或者最外面使用<code>'''</code>，如：</p>
<p><code>py print '''&quot;hello&quot; 'world' '''</code><br>
<code>&quot;hello&quot; 'world'</code></p>
<h4 id="232-转义">2.3.2 转义</h4>
<p>字符串的转义主要是用<code>\</code>和<code>r'...'</code>。<br>
<code>\</code>和 c/c++ 的用法一样，可使用<code>\n</code>等。<br>
<code>r'...'</code>是将<code>''</code>内部分一串都转义，但是不能在内部包含<code>'</code>或<code>&quot;</code>.</p>
<pre><code class="language-py">print r'\\\hhh'
</code></pre>
<blockquote>
<p>\\hhh</p>
</blockquote>
<p>若要包含<code>'</code>或<code>&quot;</code>，可用<code>r'''...'''</code>。</p>
<pre><code class="language-py">print r'''he said, &quot;hi&quot;.'''
</code></pre>
<p><code>he said, &quot;hi&quot;.</code></p>
<h4 id="233-字符串拼接">2.3.3 字符串拼接</h4>
<p>可使用 <code>+</code> 连接字符串，如：<br>
<code>py print 'hello' + ' ' + 'world'</code></p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>（不可将字符串与其他类型用 <code>+</code> 连接）<br>
或者使用 <code>,</code>会自动加一个空格（逗号自动被替换为空格）：</p>
<p><code>py print 'hello', 'world'</code></p>
<blockquote>
<p>hello world</p>
</blockquote>
<h4 id="234-中文字符">2.3.4 中文字符</h4>
<p>在 python 中，中文字符支持 Unicode 编码，因此，输出中文字符串时，需在前面加<code>u</code>（我的不需要加，可能和python版本之类的有关）。</p>
<p>如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释</p>
<pre><code class="language-py"># -*- coding: utf-8 -*-
</code></pre>
<p>目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为... 并选择UTF-8格式保存。</p>
<h3 id="24-布尔值">2.4 布尔值</h3>
<h4 id="241-基本概念">2.4.1 基本概念</h4>
<p><code>True</code> 和 <code>False</code>（首字母大写）。<br>
可对布尔值进行 <code>and</code>、<code>or</code>、<code>not</code>运算。</p>
<p>Python把<code>0</code>、空字符串<code>''</code>和<code>None</code>看成 False，其他数值和非空字符串都看成 True。</p>
<h4 id="242-短路运算">2.4.2 短路运算</h4>
<ol>
<li>
<p>在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。</p>
</li>
<li>
<p>在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。</p>
</li>
</ol>
<p>因此，</p>
<pre><code class="language-py">a = True
print a and 'a=T' or 'a=F'
</code></pre>
<p>因为<code>a = True</code>，后面为 and，所以取决于后面，因为<code>'a=T'</code> 不是空字符串，所以 也为 True，后面是or，所以取决于当前，因此输出：</p>
<blockquote>
<p>a=T</p>
</blockquote>
<h3 id="25-空值">2.5 空值</h3>
<p>用 <code>None</code> 表示，并不是 <code>0</code>，因为 0 是有意义的。</p>
<h2 id="3变量">3.变量</h2>
<h3 id="31-变量名">3.1 变量名</h3>
<p>变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头。</p>
<h3 id="32-动态语言">3.2 动态语言</h3>
<p>python的变量本身类型不固定，因此称 python 为动态语言。<br>
例如：</p>
<pre><code class="language-py">a = 123
print a
a = 'hello world'
print a
</code></pre>
<blockquote>
<p>123<br>
hello world</p>
</blockquote>
<p>定义 a 时无需指定 a 的类型，可通过赋值自动判断，当 <code>a = 123</code> 时 a 是整型，当 <code>a = 'hello world'</code> 时 a 是字符串类型，成为动态语言。</p>
<h3 id="32-具体分析">3.2 具体分析</h3>
<pre><code class="language-py">a = 123
b = a
a = 'abc'
print b
</code></pre>
<blockquote>
<p>123</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190113175437922.png" alt="指向" loading="lazy"><br>
最开始 a 和 b 都指向了内存中的 123 。<br>
<img src="https://img-blog.csdnimg.cn/20190113175550279.png" alt="在这里插入图片描述" loading="lazy"><br>
接着让 a 指向 'abc'，而 b 仍指向 123 。</p>
<h2 id="4list-tuple-类型">4.list / tuple 类型</h2>
<h3 id="41-list">4.1 list</h3>
<h4 id="411-构造">4.1.1 构造</h4>
<p>list（列表） 是 python 的内置类型，使用方法也很简单。</p>
<pre><code class="language-py">L = ['hello', 'and', 'python']
print L
</code></pre>
<blockquote>
<p>['hello', 'and', 'python']</p>
</blockquote>
<p>list 中的元素类型也不要求一样。</p>
<pre><code class="language-py">L = ['hello', 100, 'python']
print L
</code></pre>
<blockquote>
<p>['hello', 100, 'python']</p>
</blockquote>
<p>也可定义一个空list：</p>
<pre><code class="language-py">empty_list = []
</code></pre>
<h4 id="412-使用">4.1.2 使用</h4>
<p>若要指定使用的元素：</p>
<pre><code class="language-py">L = ['hello', 100, 'python']
print L[0]
print L[1]
print L[2]
</code></pre>
<blockquote>
<p>hello<br>
100<br>
python</p>
</blockquote>
<p>注意：使用时不要越界。</p>
<p>list 还可以倒序输出:</p>
<pre><code class="language-py">L = ['hello', 100, 'python']
print L[-1]
print L[-2]
print L[-3]
</code></pre>
<blockquote>
<p>python<br>
100<br>
hello</p>
</blockquote>
<h4 id="413-添加新元素">4.1.3 添加新元素</h4>
<p>使用 <code>append()</code>或 <code>insert()</code>方法添加新元素。用法也很简单：</p>
<pre><code class="language-py">L = ['hello', 100, 'python']
L.append(200)
print L
L.insert(1, 'world')
print L
</code></pre>
<pre><code>['hello', 100, 'python', 200]
['hello', 'world', 100, 'python', 200]
</code></pre>
<h4 id="414-删除元素">4.1.4 删除元素</h4>
<p>使用<code>pop()</code>方法删除元素。若该方法不传参，则默认删除最后一个元素，否则删除指定位置的元素。用法：</p>
<pre><code class="language-py">L = ['hello', 100, 'python', 'hehe', 200]
L.pop()
print L
L.pop(2)
print L
</code></pre>
<pre><code>['hello', 100, 'python', 'hehe']
['hello', 100, 'hehe']
</code></pre>
<h4 id="415-替换元素">4.1.5 替换元素</h4>
<p>与数组类似：</p>
<pre><code class="language-py">L = ['hello', 100, 'python', 'hehe', 200]
L[2] = 'sss'
print L
L[-2] = 'haha'
print L
</code></pre>
<pre><code>['hello', 100, 'sss', 'hehe', 200]
['hello', 100, 'sss', 'haha', 200]
</code></pre>
<h3 id="42-tuple">4.2 tuple</h3>
<h4 id="421-构造">4.2.1 构造</h4>
<p>tuple（元组）与 list 非常类似，但 tuple 一旦创建完，就不能修改。<br>
tuple 用<code>()</code>来括起来：</p>
<pre><code class="language-py">T = ('hello', 100, 'python', 'hehe', 200)
print T
</code></pre>
<p>此时，T 不能再修改。但可以访问，访问方法与 list 一样。</p>
<h4 id="422-单元素的tuple">4.2.2 单元素的tuple</h4>
<p>python 规定若 tuple 只有一个元素时，需要在第一个元素后面加上逗号：</p>
<pre><code class="language-py">T = ('hello', )
print T
</code></pre>
<blockquote>
<p>(hello)</p>
</blockquote>
<p>否则输出 <code>hello</code>而不是<code>(hello)</code>。</p>
<p>因为，若是不加逗号，python 解释器认为括号表示运算时的优先级，因此避免歧义，需要加一个逗号。</p>
<h4 id="423-可变tuple">4.2.3 可变tuple</h4>
<pre><code class="language-py">T = ('hello', 100, ['aaa', 'bbb'])
L = T[2]
L[0] = 'xxx'
print T
</code></pre>
<blockquote>
<p>('hello', 100, ['xxx', 'bbb'])</p>
</blockquote>
<p>可以发现，通过修改 L，改变了 T。<br>
原因是，tuple 的不可变性，体现在指向不变上。<br>
具体分析如下：<br>
<img src="https://img-blog.csdnimg.cn/20190113215240170.png" alt="分析" loading="lazy"></p>
<p>因此，当执行<code>L = T[2], L[0] = 'xxx'</code>时，L[0] 的指向发生了改变，但 T[2] 的指向仍然是指向 L，并未改变。若要创建一个无法改变的 tuple，则需 tuple 的每个元素都不可变。</p>
<h2 id="5条件判断与循环">5.条件判断与循环</h2>
<h3 id="51-if">5.1 if</h3>
<p>用法很简单：</p>
<pre><code class="language-py">if 10 &gt; 9:
    print 'yes'
</code></pre>
<blockquote>
<p>yes</p>
</blockquote>
<p>if 后面还可加 not：</p>
<pre><code class="language-py">if not 9 &gt; 10:
    print 'no'
</code></pre>
<blockquote>
<p>no</p>
</blockquote>
<p>在 <code>:</code> 后面，代表代码块的开始。</p>
<h3 id="52-if-else">5.2 if-else</h3>
<p>用法如下：</p>
<pre><code>if 11 &gt; 10:
    print 'yes'
else:
    print 'no'
</code></pre>
<blockquote>
<p>yes</p>
</blockquote>
<p>注意：else后面有<code>:</code>。</p>
<h3 id="53-if-elif-else">5.3 if-elif-else</h3>
<p>用法如下：</p>
<pre><code class="language-py">age = 3
if age &gt;= 18:
    print 'adult'
elif age &gt;= 6:
    print 'teenager'
elif age &gt;= 3:
    print 'kid'
else:
    print 'baby'
</code></pre>
<blockquote>
<p>kid</p>
</blockquote>
<p>注意，每个判断语句后面都有 <code>:</code>。</p>
<h3 id="54-for循环">5.4 for循环</h3>
<p>用法如下：</p>
<pre><code class="language-py">L = ['hello', 'why', 'yes']
for str in L:
    print str
</code></pre>
<blockquote>
<p>hello<br>
why<br>
yes</p>
</blockquote>
<p>str 变量是在 for 循环中定义的，意思是依次取出 list 中的每一个元素，赋值给 str ，然后执行缩进中的内容。<br>
注意：for 后面有L <code>:</code>，且 for 与 in 搭配。</p>
<h3 id="55-while循环">5.5 while循环</h3>
<p>格式如下：</p>
<pre><code class="language-py">a = 1
while a &lt; 5:
    print a
    a += 1
</code></pre>
<blockquote>
<p>1<br>
2<br>
3<br>
4</p>
</blockquote>
<p>注意 while 语句后面的 <code>:</code>。</p>
<h3 id="56-break与continue">5.6 break与continue</h3>
<h4 id="561-break">5.6.1 break</h4>
<pre><code class="language-py">a = 1
while True:
    print a
    a += 1
    if a &gt; 5:
        break
</code></pre>
<p>用法与c/c++类似。</p>
<h4 id="562-continue">5.6.2 continue</h4>
<p>用法与c/c++类似。这里不具体举例。</p>
<h3 id="57-多重循环">5.7 多重循环</h3>
<h2 id="6-dict-和-set-类型">6 dict 和 set 类型</h2>
<h3 id="61-dict">6.1 dict</h3>
<h4 id="611-构造">6.1.1 构造</h4>
<p>感觉类似于C++的map。是将两个类型对应起来。<br>
简单地说，list 与 tuple 中每个元素的类型都是一个已知类型，而 dict 中每个元素的类型都是一个映射（键值对key-value）。<br>
例如，我们想将一个班的每个同学的姓名与他的成绩存储下来，且需一一对应，那么用 dict ，可完成这个任务。因为 dict 中的每个元素，可以存储一个姓名与成绩的映射。用法如下：</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Kiki': 95,
    'Jack': 80
}
print d
print len(d)
</code></pre>
<blockquote>
<p>{'Kiki': 95, 'Amon': 90, 'Jack': 80}<br>
3</p>
</blockquote>
<h4 id="612-使用">6.1.2 使用</h4>
<p>d[key] = value，如下：</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Kiki': 95,
    'Jack': 80
}
print d['Amon']
</code></pre>
<p>若 d 中没有你的 key，就会报错：</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Kiki': 95,
    'Jack': 80
}
print d['Tina']
</code></pre>
<p>报错提示：</p>
<pre><code class="language-py">Traceback (most recent call last):
  File &quot;hello.py&quot;, line 6, in &lt;module&gt;
    print d['Tina']
KeyError: 'Tina'
</code></pre>
<p>因此，有个函数可以判断 dict 中是否含有某个 key：</p>
<pre><code class="language-py">if 'Tina' in d:
    print d['Tina']
</code></pre>
<p>或者使用：</p>
<pre><code class="language-py">print d.get('Tina')
</code></pre>
<p>若没有所需的key，输出 <code>None</code>，否则输出 value。<br>
这样就不会报错。</p>
<h4 id="613-dict的特点">6.1.3 dict的特点</h4>
<p>1.key 不能重复，且 key 不能变（所以 list 不能作为key）<br>
2.在 dict 中，元素是没有顺序的（所以不能用d[0], d[1]...)<br>
3.查找速度快，但占用内存大</p>
<h4 id="614-更新dict">6.1.4 更新dict</h4>
<p>添加新元素：</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Kiki': 95,
    'Jack': 80
}
d['newPerson'] = 60
print d
</code></pre>
<p><code>{'newPerson': 60, 'Kiki': 95, 'Amon': 90, 'Jack': 80}</code></p>
<h4 id="615-遍历dict">6.1.5 遍历dict</h4>
<p>与遍历 list 类似：</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Kiki': 95,
    'Jack': 80
}
for key in d:
    print key, d[key]
</code></pre>
<blockquote>
<p>Kiki 95<br>
Amon 90<br>
Jack 80</p>
</blockquote>
<h3 id="62-set">6.2 set</h3>
<h4 id="621-构造">6.2.1 构造</h4>
<p>set 与 dict 的区别的，dict 中存的是一个 key-value 的键值对，而 set 中只有 key。<br>
set 中的 key 也不能重复，相当于 set 是一个不能有重复元素的集合，且元素无序。<br>
set 的调用方法是调用他的构造函数 set()，在里面传入一个 list，list 中存的是需要传入的 key，用法如下：</p>
<pre><code class="language-py">s = set(['Amon', 'Kiki', 'Tina'])
print s
</code></pre>
<blockquote>
<p>set(['Kiki', 'Amon', 'Tina'])</p>
</blockquote>
<p>当 set 中有重复元素时，会自动去重。</p>
<h4 id="622-使用">6.2.2 使用</h4>
<p>由于 set 无序，所以我们无法通过 s[0]、s[1].. 这样的方式来调用，但可以判断某个元素是否在 set 内：</p>
<pre><code class="language-py">s = set(['Amon', 'Kiki', 'Tina'])
print 'kkk' in s
</code></pre>
<blockquote>
<p>False</p>
</blockquote>
<h4 id="623-set-的特点">6.2.3 set 的特点</h4>
<p>1.元素不能重复，且不可变（所以 list 不能作为 set 的元素）<br>
2.在 set 中，元素没有顺序（所以不能用 s[0]，s[1]...）<br>
3.判断某个元素是否在 set 中的速度很快</p>
<h4 id="624-遍历-set">6.2.4 遍历 set</h4>
<p>与 list 的遍历类似：</p>
<pre><code class="language-py">s = set(['Amon', 'Kiki', 'Tina'])
for name in s:
    print name
</code></pre>
<blockquote>
<p>Kiki<br>
Amon<br>
Tina</p>
</blockquote>
<h4 id="625-更新-set">6.2.5 更新 set</h4>
<p>添加新元素：add()<br>
删除元素：remove()<br>
（若删除元素不存在，会报错）<br>
如下：</p>
<pre><code class="language-py">s = set(['Amon', 'Kiki', 'Tina'])
s.add(100)
print s
s.remove('Amon')
print s
</code></pre>
<blockquote>
<p>set([100, 'Kiki', 'Amon', 'Tina'])<br>
set([100, 'Kiki', 'Tina'])</p>
</blockquote>
<h2 id="7函数">7.函数</h2>
<h3 id="71-python内置函数">7.1 python内置函数</h3>
<p>python 的官方文档：<br>
http://docs.python.org/2/library/functions.html#abs</p>
<p>若要查看某个函数的用法，也可以：</p>
<pre><code class="language-py">print help(abs)
</code></pre>
<pre><code>Help on built-in function abs in module __builtin__:

abs(...)
    abs(number) -&gt; number

    Return the absolute value of the argument.
</code></pre>
<h3 id="72-编写函数">7.2 编写函数</h3>
<p>定义函数使用 <code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号，例如：</p>
<pre><code class="language-py">def my_abs(x):
    if x &gt;= 0:
        return x
    else:
        return -x
a = -3
print my_abs(a)
</code></pre>
<blockquote>
<p>3</p>
</blockquote>
<p>若没有返回语句，则返回 <code>None</code>（return None），简写为<code>return</code>。<br>
他的用法用法与C/C++差不多，也可以递归调用自身。</p>
<h3 id="73-返回多值">7.3 返回多值</h3>
<p>用法如下：</p>
<pre><code class="language-py">def my_abs(x1, x2, x3):
    return abs(x1), abs(x2), abs(x3)
a = -3
b = 2
c = -5
print my_abs(a, b, c)
</code></pre>
<blockquote>
<p>(3, 2, 5)</p>
</blockquote>
<p>返回值是一个 tuple。</p>
<h3 id="74-默认参数">7.4 默认参数</h3>
<p>和C++的默认参数差不多。</p>
<pre><code class="language-py">def sum(x1, x2, x3 = 0, x4 = 0):
    return x1 + x2 + x3 + x4
a = -3
b = 2
print sum(a, b)
</code></pre>
<blockquote>
<p>-1</p>
</blockquote>
<h3 id="75-可变参数">7.5 可变参数</h3>
<p>用法如下：</p>
<pre><code class="language-py">def sum(*args):
    ans = 0
    for em in args:
        ans += em
    return ans
print sum(2, 3, -6)
</code></pre>
<blockquote>
<p>-1</p>
</blockquote>
<p>在参数前加 <code>*</code>，代表这是一个可变参数，相当于是一个 tuple。<br>
和C/C++的可变参数略有不同。</p>
<h2 id="8切片">8.切片</h2>
<h3 id="81-切片简述">8.1 切片简述</h3>
<p>若想遍历一个 list 的前 n 个元素，可这样做：</p>
<pre><code class="language-py">L = [4, 26, 8, 2, 11, 33, 27]
for i in range(5):
    print L[i]
</code></pre>
<blockquote>
<p>4<br>
26<br>
8<br>
2<br>
11</p>
</blockquote>
<p>range(n) 代表 0~（n-1）之间的数，让 i 等于这些数，再调用 L[i]。<br>
而 python 中的切片操作能达到相同的效果：</p>
<pre><code class="language-py">L = [4, 26, 8, 2, 11, 33, 27]
print L[0:5]
</code></pre>
<blockquote>
<p>[4, 26, 8, 2, 11]</p>
</blockquote>
<p><code>[a, b]</code> 是一个前闭后开的区间，代表第 a 个元素到第 b 个元素，但不包括第 b 个。<br>
<code>[:]</code>代表所有元素。<br>
<code>[::a]</code>代表每 a 个元素取一个元素。</p>
<pre><code class="language-py">L = [4, 26, 8, 2, 11, 33, 27]
print L[::2]
</code></pre>
<blockquote>
<p>[4, 8, 11, 27]</p>
</blockquote>
<p>同样，对 tuple 也可切片。</p>
<h3 id="82-倒序切片">8.2 倒序切片</h3>
<p>python 支持 L[-1] 取最后一个元素，同样也支持 L[-1:] 倒数切片：</p>
<pre><code class="language-py">L = [4, 26, 8, 2, 11, 33, 27]
print L[-3:]
print L[:-3]
print L[-5:-2]
print L[-6:-2:2]
</code></pre>
<blockquote>
<p>[11, 33, 27] （倒数三个数）<br>
[4, 26, 8, 2] （第一个数到倒数第三个数（不包括））<br>
[8, 2, 11]（倒数第五个数到倒数第三个数（不包括））<br>
[26, 2]（每2个中1个，倒数第六个数到倒数第二个数（不包括））</p>
</blockquote>
<h3 id="83-字符串切片">8.3 字符串切片</h3>
<p>字符串和 Unicode 也可以看做是一种 list，每个字符是一个元素。如下：</p>
<pre><code class="language-py">print 'hello world'[2:7]
</code></pre>
<blockquote>
<p>llo w</p>
</blockquote>
<h2 id="9迭代">9.迭代</h2>
<h3 id="91-迭代的概念">9.1 迭代的概念</h3>
<p>在python中，迭代就是指 for 循环。for 循环可以作用在有序或无序集合上。</p>
<h3 id="92-索引迭代">9.2 索引迭代</h3>
<p><code>Python中，迭代永远是取出元素本身，而非元素的索引（下标）。</code><br>
若需要元素的索引，可使用 enumerate() 函数，他将一个集合变成了每个元素为 tuple 的集合。如下：<br>
<code>L = ['Amon', 'Kiki', 'Tina']</code><br>
=&gt; <code>L = [(0, 'Amon'), (1, 'Kiki'), (2, 'Tina')]</code></p>
<p>再对他进行迭代：</p>
<pre><code class="language-py">L = ['Amon', 'Kiki', 'Tina']
for i, name in enumerate(L):
    print i, name
</code></pre>
<blockquote>
<p>0 Amon<br>
1 Kiki<br>
2 Tina</p>
</blockquote>
<h3 id="93-迭代dict">9.3 迭代dict</h3>
<p>dict 在 for 循环中，每次可以取出他的一个 key。若我们想迭代 value ，可用 values() 方法。</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Tina': 60,
    'Kiki': 80
}
print d.values()
for grade in d.values():
    print grade
</code></pre>
<blockquote>
<p>[80, 90, 60]<br>
80<br>
90<br>
60</p>
</blockquote>
<p>values() 方法实际上将 dict 转化为一个包含 values 的 list。<br>
除了 values() 方法，python 中还提供了 itervalues() 方法：</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Tina': 60,
    'Kiki': 80
}
print d.itervalues()
for grade in d.itervalues():
    print grade
</code></pre>
<blockquote>
<p>&lt;dictionary-valueiterator object at 0x102930730&gt;<br>
80<br>
90<br>
60</p>
</blockquote>
<p>itervalues() 方法不会将 dict 转换，而是在每次迭代过程中，取出 value，所以更节约内存。</p>
<p>除此之外，我们还可以使用 items() 方法同时迭代 key 和 value，items() 方法将 dict 对象转换成了包含 tuple 的 list。</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Tina': 60,
    'Kiki': 80
}
print d.items()
</code></pre>
<blockquote>
<p>[('Kiki', 80), ('Amon', 90), ('Tina', 60)]</p>
</blockquote>
<p>所以，对 d.items() 进行迭代，即可得到 key 和 value：</p>
<pre><code class="language-py">d = {
    'Amon': 90,
    'Tina': 60,
    'Kiki': 80
}
for key, value in d.items():
    print key, ':', value
</code></pre>
<blockquote>
<p>Kiki : 80<br>
Amon : 90<br>
Tina : 60</p>
</blockquote>
<h2 id="10列表生成式">10.列表生成式</h2>
<h3 id="101-简述">10.1 简述</h3>
<p>当我们想将一个 list 中的元素设置为 1<em>1，2</em>2，3<em>3 ... 10</em>10，若是一个个的赋值，过于复杂，可用列表生成式用一行搞定：</p>
<pre><code class="language-py">L = [x * x for x in range(1, 11)]
print L
</code></pre>
<blockquote>
<p>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</p>
</blockquote>
<p>但若是我们只要 x 为偶数的情况呢？可在列表生成式中加入条件判断：</p>
<pre><code class="language-py">L = [x * x for x in range(1, 11) if (x % 2 == 0)]
print L
</code></pre>
<blockquote>
<p>[4, 16, 36, 64, 100]</p>
</blockquote>
<h3 id="102-多层嵌套">10.2 多层嵌套</h3>
<p>如下：</p>
<pre><code class="language-py">print [a + str(b) for a in 'avsde' for b in range(1, 3)]
</code></pre>
<blockquote>
<p>['a1', 'a2', 'v1', 'v2', 's1', 's2', 'd1', 'd2', 'e1', 'e2']</p>
</blockquote>
<h2 id="参考">参考</h2>
<p>https://www.imooc.com/learn/177</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux下的俄罗斯方块小游戏（C++）]]></title>
        <id>https://ccccj.github.io/iD9oFb5W-/</id>
        <link href="https://ccccj.github.io/iD9oFb5W-/">
        </link>
        <updated>2019-01-05T14:10:52.000Z</updated>
        <content type="html"><![CDATA[<p>补上之前的..</p>
<p><ul class="markdownIt-TOC">
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF">主要思路</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91">简单的逻辑</a>
<ul>
<li><a href="#%E4%B8%80-linux%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6">一、Linux终端显示控制</a></li>
<li><a href="#%E4%BA%8C-%E8%83%8C%E6%99%AF%E5%9C%B0%E5%9B%BE">二、背景地图</a></li>
<li><a href="#%E4%B8%89-%E7%BB%98%E5%88%B6%E5%8D%B3%E5%B0%86%E8%A6%81%E4%B8%8B%E8%90%BD%E7%9A%84%E6%96%B9%E5%9D%97">三、绘制即将要下落的方块</a></li>
<li><a href="#%E5%9B%9B-%E6%97%8B%E8%BD%AC%E6%96%B9%E5%9D%97">四、旋转方块</a></li>
<li><a href="#%E4%BA%94-%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%8F%B3%E7%A7%BB">五、左移和右移</a></li>
</ul>
</li>
<li><a href="#%E9%9A%BE%E7%82%B9">难点</a>
<ul>
<li><a href="#%E5%85%AD-%E7%BB%88%E7%AB%AF%E7%9A%84%E9%9D%9E%E8%A7%84%E8%8C%83%E6%A8%A1%E5%BC%8F">六、终端的非规范模式</a></li>
<li><a href="#%E4%B8%83-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E6%8C%89%E9%94%AE">七、获取用户的按键</a></li>
<li><a href="#%E5%85%AB-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">八、I/O多路复用</a></li>
</ul>
</li>
<li><a href="#%E6%94%B6%E5%B0%BE">收尾</a>
<ul>
<li><a href="#%E4%B9%9D-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9F%E5%8F%98%E5%BD%A2%E6%88%96%E4%B8%8B%E7%A7%BB-%E6%B6%88%E8%A1%8C">九、判断是否能够变形或下移、消行</a></li>
<li><a href="#%E5%8D%81-%E6%96%B9%E5%9D%97%E5%9B%BE%E5%BD%A2%E5%A0%86%E7%A7%AF%E5%88%B0%E5%9C%B0%E5%9B%BE%E4%B8%8A">十、方块图形堆积到地图上</a></li>
<li><a href="#%E5%8D%81%E4%B8%80-%E5%88%A4%E6%96%AD%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F">十一、判断游戏结束</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="简介">简介</h1>
<p>之前写的俄罗斯方块的小游戏，一开始拿mac的unix写的，然后写着写着发现，好多库没有<br>
心酸，最后换了服务器用linux写完了。</p>
<p>参考了一些别人的博客，但当时参考完就被我关了，现在也不清楚当时到底看了哪些了..</p>
<p>总体来说写的还是有点乱，而且并不完善</p>
<p>丑是丑了点，害</p>
<p>效果图：<br>
<img src="https://user-images.githubusercontent.com/33253635/148509036-4300fcf7-1b2d-47a0-8f2a-f236fdbb6b6e.png" alt="" loading="lazy"></p>
<p>消行后：<br>
<img src="https://user-images.githubusercontent.com/33253635/148509062-2e97ec24-860d-4351-b48c-1149d3d26b4b.png" alt="" loading="lazy"></p>
<p>堆积方块：<br>
<img src="https://user-images.githubusercontent.com/33253635/148509118-4beda93f-1c22-4434-bbd8-0e945393785e.png" alt="" loading="lazy"></p>
<h1 id="主要思路">主要思路</h1>
<p>在终端设置一篇区域作为俄罗斯方块下降的地图，方块会定时下落，当落到最下面时，堆积到原本的地图上，方块每隔一秒下降一格，同时监测键盘是否在按方向键而改变方块的位置。行满时会消行。新刷新的方块不能再下落时，游戏结束。</p>
<h1 id="简单的逻辑">简单的逻辑</h1>
<p>我的代码的所有函数都是用类的，但是下面单独的每个函数我没表示出类，实际上每个函数前面都要有 <strong>Map::</strong> 的。</p>
<h2 id="一-linux终端显示控制">一、Linux终端显示控制</h2>
<p>用的 VT100，通过 printf 的格式化输出，在终端显示不同的方块颜色。<br>
如，</p>
<blockquote>
<p>printf(&quot;\033[%d;%dH&quot;, x, y); // 设置光标位置<br>
printf(&quot;\033[%dm\033[%dm  &quot;, color, color); // 对光标处上色</p>
</blockquote>
<p>将终端上坐标 (x, y) 处设置为颜色color。x，y，color均为传入的参数。<br>
具体用法可以参考如下：</p>
<blockquote>
<p><a href="https://blog.csdn.net/aiwangtingyun/article/details/79524899">https://blog.csdn.net/aiwangtingyun/article/details/79524899</a><br>
<a href="https://blog.csdn.net/liufei191010/article/details/81015445">https://blog.csdn.net/liufei191010/article/details/81015445</a></p>
</blockquote>
<p>突然发现，我应该隐藏光标的，忘记了...害</p>
<p>具体封装的函数：</p>
<pre><code>void Map::setColor(int x, int y, int color) {
    ++x; // 第一行会没掉
    ++y;
    y *= 2; // 每个 y 占两格，所以乘 2
    printf(&quot;\033[%d;%dH&quot;, x, y); // \033[y;xH 设置光标位置
    // \033[40m  \033[40m将一个空格 背景变为黑色
    printf(&quot;\033[%dm\033[%dm  &quot;, color, color);
    fflush(stdout);
    printf(&quot;\033[0m\033[0m&quot;); // 恢复
    printf(&quot;\033[30;0H&quot;);
}
</code></pre>
<h2 id="二-背景地图">二、背景地图</h2>
<pre><code>#define HEIGHT 10
#define WIDTH 20

int map[HEIGHT][WIDTH];
</code></pre>
<p>在析构函数中，初始化map数组：</p>
<pre><code>for (int i = 0; i &lt; HEIGHT; ++i) {
    for (int j = 0; j &lt; WIDTH; ++j) {
        // 用的47而不是0是因为，前景色是47，方便到时候涂色
        // 47代表地图的该处无障碍物，不是47代表该处有障碍物
        map[i][j] = 47;
    }
}
</code></pre>
<p>对地图上色，绘制出初始地图：</p>
<pre><code>void Map::setMapColor() {
    for (int i = 0; i &lt; HEIGHT; ++i) {
        for (int j = 0; j &lt; WIDTH; ++j) {
            setColor(i, j, map[i][j]);
        }
    }
}
</code></pre>
<p>一开始就是这样的（忽略掉那个蓝的）：<br>
<img src="https://user-images.githubusercontent.com/33253635/148512947-151e165e-0850-498b-87b6-6881bdcc8bc0.png" alt="" loading="lazy"></p>
<h2 id="三-绘制即将要下落的方块">三、绘制即将要下落的方块</h2>
<p>一共七种，每种都可以用4x4的数组来表示：</p>
<pre><code>int figure[7][4][4] = {
        /*
        0010 0100 0010 0110 0100 0010 0010
        0010 0100 0010 0110 0110 0110 0110
        0010 0110 0010 0000 0010 0100 0010
        0010 0000 0000 0000 0000 0000 0000
        */
        {{0,0,1,0},{0,0,1,0},{0,0,1,0},{0,0,1,0}},
        {{0,1,0,0},{0,1,0,0},{0,1,1,0},{0,0,0,0}},
        {{0,0,1,0},{0,0,1,0},{0,1,1,0},{0,0,0,0}},
        {{0,1,1,0},{0,1,1,0},{0,0,0,0},{0,0,0,0}},
        {{0,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,0,0}},
        {{0,0,1,0},{0,1,1,0},{0,1,0,0},{0,0,0,0}},
        {{0,0,1,0},{0,1,1,0},{0,0,1,0},{0,0,0,0}}
    };
</code></pre>
<p>经过旋转后，又可以变出更多种。后面再讲旋转。</p>
<p>每次在七种里面选一个，用随机函数来选：</p>
<pre><code>int Map::random_num() {
    return rand() % 7;
}
</code></pre>
<p>当前这个图形下落到了哪里，用一个结构体表示他的坐标：</p>
<pre><code>struct Axis {
    int x;
    int y;
} axis;
</code></pre>
<p>并在析构函数中对坐标进行初始化：</p>
<pre><code>axis = {0, WIDTH / 2 - 2};
</code></pre>
<p>对每个图形的颜色初始化（除了黑色，其他颜色是41~46）：</p>
<pre><code>for (int t = 0; t &lt; 7; ++t) {
    int cl = rand() % 6 + 41;
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            if (figure[t][i][j]) {
                figure[t][i][j] = cl;
            }
        }
    }
}
</code></pre>
<p>在终端上绘制即将下落的图形：</p>
<pre><code>void Map::drawing() {
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            if (figure[num][i][j]) setColor(axis.x + i, axis.y + j, figure[num][i][j]);
        }
    }
}
</code></pre>
<h2 id="四-旋转方块">四、旋转方块</h2>
<p>没啥好讲的，简单推理下就能推出来：</p>
<pre><code>void Map::rotate() {
    int B[4][4];
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            B[j][4 - i - 1] = figure[num][i][j];
        }
    }
    // 这里是要判断旋转后会不会装上障碍物。或者出边界，后面细讲
    if (can_change(axis.x, axis.y, B) == 0) return;
	
	// 旋转完了要把以前的图形消掉，绘制新的图形
    de_drawing();  // 消掉原来的图形
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            figure[num][i][j] = B[i][j];
        }
    }
    drawing(); // 绘制新的图形
}
</code></pre>
<p>关于消除旋转前的图形：</p>
<pre><code>void Map::de_drawing() {
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            if (figure[num][i][j]) setColor(axis.x + i, axis.y + j, 47); // 47就是背景色
        }
    }
}
</code></pre>
<h2 id="五-左移和右移">五、左移和右移</h2>
<p>和前面那个 rotate 的思路差不多。先判断能不能移动，消除原本的图形，移动，再绘制新的图形。</p>
<pre><code>void Map::left() {
    if (can_change(axis.x, axis.y - 1, figure[num]) == 0)
        return;
    de_drawing();
    --axis.y;
    drawing();
}

void Map::right() {
    if (can_change(axis.x, axis.y + 1, figure[num]) == 0)
        return;
    de_drawing();
    ++axis.y;
    drawing();
}
</code></pre>
<h1 id="难点">难点</h1>
<h2 id="六-终端的非规范模式">六、终端的非规范模式</h2>
<p>所谓终端的非规范模式，即缓存和编辑功能关闭，这也挺好理解的，有缓存咋能按一个键立马图形就变了呢。</p>
<blockquote>
<p>int tcgetattr(int fd, struct termios *termios_p);</p>
</blockquote>
<p>用于获取与终端相关的参数，成功返回零；失败返回非零。<br>
参数 fd 为终端的文件描述符，返回的结果保存在 termios 结构体中，<br>
termios 结构体中有：</p>
<blockquote>
<p><strong>tcflag_t c_lflag</strong></p>
</blockquote>
<p>c_lflag中，<strong>ECHO宏</strong>（打开，输入了什么会显示在屏幕，所以要关闭）<br>
c_lflag中，<strong>ICANON</strong>是规范模式（所以要关掉这个标志，就变成非规范模式）</p>
<p>这两个都关闭的话：</p>
<blockquote>
<p>t.c_lflag &amp;= ~(ECHO | ICANON); // 关闭c_lflag中的ECHO和ICANON</p>
</blockquote>
<p>设置终端属性：</p>
<blockquote>
<p>int tcsetattr(int fd, int when, struct termios *info);</p>
</blockquote>
<pre><code>void Map::set_termio() {
    struct termios t;
    tcgetattr(0, &amp;t); // 0：标准输入
    t.c_lflag &amp;= ~(ECHO | ICANON); // 关闭c_lflag中的ECHO和ICANON
    t.c_lflag &amp;= ~ISIG;
    tcsetattr(0, TCSANOW, &amp;t); // TCSANOW 表示立即
}
</code></pre>
<p>简单来说就是获取原本的终端参数，修改<strong>ECHO宏</strong>和<strong>ICANON</strong>，最后再作为参数传入，修改终端参数。</p>
<p>恢复终端参数：</p>
<pre><code>void Map::recover_termio() {
    struct termios t;
    tcgetattr(0, &amp;t); // 0：标准输入
    t.c_lflag |= ECHO | ICANON; // 打开c_lflag中的ECHO和ICANON

    // 设置终端属性
    // int tcsetattr(int fd, int when, struct termios *info);
    tcsetattr(0, TCSANOW, &amp;t); // TCSANOW 表示立即
}
</code></pre>
<p>这，看着放吧，我的代码里好多地方都放了，比如，按<strong>q</strong>退出的时候放了个，<em>game over</em> 的时候放了个。</p>
<h2 id="七-获取用户的按键">七、获取用户的按键</h2>
<p>用了一个枚举类型，看着好看点吧。</p>
<pre><code>enum Direction {
    CHANGE = 65, // 方向键上
    DOWN = 66,
    RIGHT = 67,
    LEFT = 68,
    QUIT = 'q',
};
</code></pre>
<p>试了几次才发现，按方向键的话，前面会出现几个其他的字符，第一个的 ascii 是27，后面好像还有 [[ 来着，这里设置方向键向上是旋转，向下是一键到底（后面讲）。</p>
<pre><code>void Map::get_char() {
    fflush(stdin);
    char c = getchar();
    if (c == QUIT) {
        recover_termio();
        exit(0);
    } else if (c == 27) {
        c = getchar();
        c = getchar();
        switch (c) {
            case CHANGE: rotate();break;
            case DOWN: fall(); break;
            case RIGHT: right(); break;
            case LEFT: left(); break;
        }
    }
}
</code></pre>
<h2 id="八-io多路复用">八、I/O多路复用</h2>
<p>进入最难的地方，也是我花时间最多的地方。</p>
<p>一开始也没明白为啥要并发，后来写着写着发现不得不用。因为原本的逻辑是一秒向下移一个，但是同时还需要处理用户键盘的输入，不得不并发。</p>
<p>最开始想的是用 fork 两个子进程，一个子进程监测键盘，有输入了就发个信号，一个子进程监测时钟，一秒发一次信号。</p>
<p>然后写着写着发现，这不行啊..信号处理函数只能穿信号这个参数，那我啥都干不了啊..网上和书上找来找去，只有在信号处理函数里面搞个输出的，也没去其他的例子。</p>
<p>后来看到 sigqueue 这个函数，可以传值或者指针，本来想试试，然而不知道为啥，我的 mac上的 signal.h 里面没有这个函数，心累。</p>
<p>后来又看了网上很多人用的 I/O多路复用，用了 select。用 timerfd_create 函数创建一个时钟的句柄。</p>
<p>但是 timerfd_create 是Linux专用的，最后换了服务器写的。</p>
<p>函数原型：</p>
<blockquote>
<p>int select(int nfds, fd_set *readfds, fd_set *writefds,<br>
fd_set *exceptfds, struct timeval *timeout);</p>
</blockquote>
<pre><code>nfds：待测试的描述符个数，它的值是待测试的最大描述符加1。

readfds：监测读文件的变化，要监测的文件的句柄放在这个集合内，stdin（标准输入）也将其看做文件，句柄为 STDIN_FILENO（实际上就是0），原本 select 会使进程处于阻塞状态，当该集合中任意一个读 被检测到，就会停止阻塞，我们就可以判断是哪个读文件发生了变化，进而去读取内容。

writefds：监测写文件的变化，和上面的读原理一样，我们这里不用，用 NULL 即可。

exceptfds：这个参数用来检测文件有无异常情况发生。

timeout：最大的阻塞的时间，即超时时间后也没有读写发生，就会停止阻塞，因为我们这里无论如何每秒都会产生一格读使得方块下移，所以不设置这个时间（即 时间为无限长），用 NULL 即可。
</code></pre>
<p>标准输入的文件描述符比较简答：STDIN_FILENO，但是还需要有一个定时器描述符，每隔一秒发生一个读。<br>
<strong>timerfd_create</strong>函数将时间变成一个文件描述符，在超时的时候变成可读：</p>
<blockquote>
<p>int tfd = timerfd_create(CLOCK_MONOTONIC, 0);</p>
</blockquote>
<p><strong>timerfd_settime</strong>函数对时间句柄进行设置，如每隔多长时间变得可读：</p>
<blockquote>
<p>int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);</p>
</blockquote>
<p>timespec 和 itimerspec 都是结构体，如下：</p>
<pre><code>struct timespec {
    time_t tv_sec; // 秒
    long   tv_nsec; // 毫秒
};

struct itimerspec {
    struct timespec it_interval; //每隔多长时间超时
    struct timespec it_value; // 第一次超时时间
};
</code></pre>
<p>具体代码如下，标了注释，应该挺好理解的：</p>
<pre><code>int tfd = timerfd_create(CLOCK_MONOTONIC, 0);
struct itimerspec it = {{1, 0}, {1, 0}};
timerfd_settime(tfd, 0, &amp;it, NULL);
int tt = 300;
while(tt--) {
    fd_set read_set; // 描述符集合 读集合
    FD_ZERO(&amp;read_set); // 创建一个空的读集合
    FD_SET(STDIN_FILENO, &amp;read_set); // 将标准输入描述符加入读集合
    FD_SET(tfd, &amp;read_set);

    //struct timeval tvl = {1, 0}; // 最多阻塞一秒
    // 阻塞，直到集合中某个描述符可以读
    select(tfd + 1, &amp;read_set, NULL, NULL, NULL);

    // FD_ISSET 判断哪个哪个描述符已经可以读了
    if (FD_ISSET(STDIN_FILENO, &amp;read_set)) {
        get_char();
    } else {
        // tfd
        int ret = down();
        if (ret == 0) re_init();
        uint64_t data;
        read(tfd, &amp;data, sizeof data);
    }
}
close(tfd);
</code></pre>
<h1 id="收尾">收尾</h1>
<h2 id="九-判断是否能够变形或下移-消行">九、判断是否能够变形或下移、消行</h2>
<p>主要是看，如果在4x4内是有方块的，那么这一格超出边界就返回0；如果会撞上地图的障碍物，也返回0.</p>
<pre><code>bool can_change(int x, int y, int Mo[][4]) {
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            if (Mo[i][j]
                &amp;&amp; (x + i &gt;= HEIGHT || y + j &gt;= WIDTH || x + i &lt; 0 || y + j &lt; 0)) {
                return 0;
            }
            if (Mo[i][j] &amp;&amp; map[x + i][y + j]-47) return 0;
        }
    }
    return 1;
}

bool can_down() {
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            if (figure[num][i][j] &amp;&amp; (axis.x+i+1 &gt;= HEIGHT || axis.y+j &gt;= WIDTH)) {
                return 0;
            }
            if (figure[num][i][j] &amp;&amp; map[axis.x+i+1][axis.y+j]-47) return 0;
        }
    }
    return 1;
}
</code></pre>
<h2 id="十-方块图形堆积到地图上">十、方块图形堆积到地图上</h2>
<p>当不能再下移时，就把图形堆积到地图上。</p>
<pre><code>if (can_down()) return;
// 不可以下移
for (int i = 0; i &lt; 4; ++i) {
    for (int j = 0; j &lt; 4; ++j) {
        if (figure[num][i][j]) map[axis.x + i][axis.y + j] = figure[num][i][j];
    }
}
</code></pre>
<h2 id="十一-判断游戏结束">十一、判断游戏结束</h2>
<p>当发现新刷新出来的图形，不能下落时，判断游戏结束：</p>
<pre><code>if (can_down() == 0) {\
    printf(&quot;\033[2J&quot;); // 清屏
    printf(&quot;game over\n&quot;);
    recover_termio();
    exit(0);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ | 函数重载]]></title>
        <id>https://ccccj.github.io/c-or-han-shu-chong-zai/</id>
        <link href="https://ccccj.github.io/c-or-han-shu-chong-zai/">
        </link>
        <updated>2018-04-05T09:31:36.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%98%AF%E4%BB%80%E4%B9%88">函数重载是什么</a></li>
<li><a href="#%E5%8F%AF%E4%BB%A5%E6%9E%84%E6%88%90%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A6%81%E6%B1%82">可以构成重载的要求</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E8%A6%81%E6%B1%82">参数列表的要求</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E7%82%B9">其他注意点</a></li>
<li><a href="#1-%E7%B1%BB%E5%9E%8B%E9%9C%80%E8%A6%81%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8D">1、类型需要完全匹配</a></li>
<li><a href="#2-%E6%B3%A8%E6%84%8F%E5%BC%95%E7%94%A8">2、注意引用</a></li>
<li><a href="#3-const-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D">3、const 指针类型匹配</a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E8%BD%BD%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">重载引用参数</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E9%87%87%E7%94%A8%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">何时采用函数重载</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86">函数重载的原理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="函数重载是什么">函数重载是什么</h3>
<p><strong>缺省参数</strong>让我们在参数数目不同时可以调用同一个函数（不清楚的可以看下我 C++ 零碎知识点集合 那篇博客），而<strong>函数重载</strong>让我们能够使用多个<strong>同名函数</strong>。</p>
<hr>
<p>（其实写完这篇博客，觉得举这个例子不是很好..因为很多人并不是像我一样，先接触了 STL 再学习的 C++，看这篇博客的很多人应该并不理解 vector 之类的...然而已经写完了...）</p>
<p>第一次接触函数缺省参数应该是在使用 STL 的各种容器的时候，那时候还没开始学 C++，但是一直听说做题的时候容器很好用，就试着用了下。当时第一个用的是 vector，对于它的构造方法觉得惊为天人...<br>
（其实这里举这个例子可能会有些听不懂...虽然可以再讲很多别的例子..但是对我印象最深刻的函数重载就是这个= =）</p>
<p>刚才特地去 cplusplus 上验证了下到底是重载还是参数缺省..事实证明就是重载..推荐大家多用这个网站..真的好用<sup>o</sup></p>
<figure data-type="image" tabindex="1"><img src="https://user-images.githubusercontent.com/33253635/149073979-eccac0b5-7960-4dd8-84d1-09fc9a70abd1.png" alt="vector" loading="lazy"></figure>
<p>关于 const allocator_type&amp; alloc 这个参数我们暂时不用管（百度了下是模板..然而没学过..只能暂时不管了...），只需要看其他的即可 。<br>
这里声明了几个的 vector 的构造函数，从这也能看出传参方式不同：</p>
<pre><code>1. 无参数；
2. 传一个 n 来设定 vector 的初始元素个数；
3. 传 n 设定元素个数，传 value 设定每个元素的初始值；
4. 是拷贝构造，传入一个 vector 的对象；
5. 传两个迭代器，设定第一个元素的地址与最后一个元素的下一位置的地址。
</code></pre>
<p>暂时只能看懂以上构造函数，但是也可以说明一个问题，那就是，<strong>当我们传入的参数不同时，所调用的函数也会不同</strong>。</p>
<figure data-type="image" tabindex="2"><img src="https://user-images.githubusercontent.com/33253635/149073988-ebe3bee4-7c84-484f-afd2-fee7e88e2a80.png" alt="构造方法" loading="lazy"></figure>
<p>这里是几个构造方法的例子，分别对应了我上面所举的例子的 1、3、5、4 这四种方法。</p>
<p>到这里有没有稍微明白一点<strong>函数重载</strong>到底是什么呢？</p>
<blockquote>
<p>函数重载即，我们设计一系列函数——他们有相同的函数名，并且完成相同的工作，但有不同的参数列表。</p>
</blockquote>
<p>C++ 相对于 C 引入了函数重载，很方便的解决了我们很多问题，就像之前那个 vector 的几种构造方法一样，他们略微有一些差异，但最终实现的功能是一样的，我们可以根据他们的功能来记住这一类函数的名字，但若是每个函数都有不同的名字，调用时便会很不方便。</p>
<h3 id="可以构成重载的要求">可以构成重载的要求</h3>
<h4 id="参数列表的要求">参数列表的要求</h4>
<p>但不是所有函数都可以重名的。函数重载也有前提：<strong>参数列表不同</strong>。<br>
函数的<strong>参数列表</strong>也成为<strong>函数特征标</strong>。他由三个特性构成：</p>
<pre><code>1. 参数数目和类型
2. 参数的排列顺序
</code></pre>
<p>也就是说，有两个函数，在这两点中有任意一点不同，我们称其参数列表（特征标）不同。</p>
<p>注意，我们所说的是要求参数列表（特征标）不同，而不是函数类型不同，以下这两个声明是<strong>互斥</strong>的：</p>
<pre><code>int test(int x);
double test(int x);
</code></pre>
<p>但是当参数列表不同时，返回类型可以不同：</p>
<pre><code>int test(int x);
double test(float x);
</code></pre>
<p><mark><strong>总结</strong></mark>：需要使用函数重载，其参数列表必须不同，而返回类型可不同也可相同（具体原因后面会讲）。</p>
<h4 id="其他注意点">其他注意点</h4>
<h4 id="1-类型需要完全匹配">1、类型需要完全匹配</h4>
<p>在使用时有很多地方需要我们注意：</p>
<pre><code>	void test(int a); 
	void test(float f);
</code></pre>
<p>这时候如果调用：</p>
<pre><code>double t = 1;
test(t);
</code></pre>
<p>当 test 函数没有重载时，传入参数类型若不匹配，编译器便会将类型强转，然而现在有了两种转换 t 的方式，编译器便会将其视为错误。</p>
<h4 id="2-注意引用">2、注意引用</h4>
<p>另外，有些看起来彼此不同的参数列表是不能共存的：</p>
<pre><code>void test(int x);
void test(int&amp; x);
</code></pre>
<p>的确，您可能认为他们参数列表不同，可是换一种考虑方式：当您调用</p>
<pre><code>    int a = 1;
    test(a);
</code></pre>
<p>这时候两个函数都匹配，又让编译器去调用哪个呢？为了避免这种情况，编译器在检查函数特征标时，将类型本身与类型引用视为同一特征标。</p>
<h4 id="3-const-指针类型匹配">3、const 指针类型匹配</h4>
<p>看下面一个简单的例子：</p>
<pre><code>void test(const char* s) {
    cout &lt;&lt; &quot;test1&quot; &lt;&lt; endl;
}

void test(char* s) {
    cout &lt;&lt; &quot;test2&quot; &lt;&lt; endl;
}

int main() {
    const char a[] = &quot;hello&quot;;
    char b[] = &quot;hello&quot;;
    test(a);
    test(b);
    return 0;
}
</code></pre>
<p>输出结果：</p>
<blockquote>
<p>test1<br>
test2</p>
</blockquote>
<p>可以看出，const 修饰的参数会与 const 类型匹配，而非 const 参数与非 const 类型匹配，但是注意，若不是指针，而是普通变量，编译器则会报错：</p>
<pre><code>void test(int x);
void test(const int x);
</code></pre>
<p>上面的代码编译器会提示你函数重定义，说明编译器并不区分const变量与非const变量（我的猜测是，无论是不是const变量，对于原变量，都不会修改，因为参数是原本参数的一份拷贝，因此，除指针和引用外的变量，是不是const变量都无所谓）。</p>
<h3 id="重载引用参数">重载引用参数</h3>
<p>在C++中经常用到引用，因此重载引用参数也值得探讨。</p>
<pre><code>void test(double &amp; x);
void test(const double &amp; x);
void test(double &amp;&amp; x);
</code></pre>
<p>可能有人是第一次见两个引用符号...比如我...<br>
下面具体解释下这三种参数对应的传参：</p>
<ol>
<li>形参为 可变的左值；</li>
<li>形参为 可变的左值、不可变的左值 或 右值</li>
<li>形参为 右值（最后这个书上说 rvalue，但翻译又说是左值，怀疑是写错了）。</li>
</ol>
<p>可以发现，可变的左值既可匹配 1 也可匹配 2；右值既可匹配 2 又可匹配 3；那么到底如何匹配呢？<br>
答案是：选择最匹配的。<br>
看下面一个对比就明白了：</p>
<pre><code>void test(double&amp; x) {
    cout &lt;&lt; &quot;test1&quot; &lt;&lt; endl;
}

void test(const double&amp; x) {
    cout &lt;&lt; &quot;test2&quot; &lt;&lt; endl;
}

void test(double&amp;&amp; x) {
    cout &lt;&lt; &quot;test3&quot; &lt;&lt; endl;
}

int main() {
    double a = 1;
    const double b = 2;
    test(a);
    test(b);
    test(a + b);
    return 0;
}
</code></pre>
<p>答案：</p>
<blockquote>
<p>test1<br>
test2<br>
test3</p>
</blockquote>
<p>这里 a 为左值，所以匹配最匹配的 test1，b 为不可变的左值，所以匹配 test2， a+b 为右值，所以匹配最匹配的 test3。而下一个例子则不是：</p>
<pre><code>void test(const double&amp; x) {
    cout &lt;&lt; &quot;test2&quot; &lt;&lt; endl;
}

int main() {
    double a = 1;
    const double b = 2;
    test(a);
    test(b);
    test(a + b);
    return 0;
}
</code></pre>
<p>答案：</p>
<blockquote>
<p>test2<br>
test2<br>
test2</p>
</blockquote>
<p>这里的三个答案均为 test2，是因为 a 和 a+b 没有最原本那两个选择，最匹配的变为了 test2。这就是<strong>选择最匹配</strong>的意思。</p>
<h3 id="何时采用函数重载">何时采用函数重载</h3>
<p>当我们的函数将执行相同的任务，但使用不同形式的数据时，可采用函数重载。当然，并不是所有时候都需要用到函数重载，有些地方用缺省参数会更方便些。</p>
<h3 id="函数重载的原理">函数重载的原理</h3>
<p>想要明白函数的原理，就需要先明白<strong>名称修饰</strong>（名称矫正）。什么是名称修饰呢？<br>
我们的编译器在<strong>编译</strong>阶段，将函数名进行了修饰，将其从原本的函数名，变为了修饰后的修饰名。在调用函数的时候，并不是按函数名去直接调用函数的，而是按照<strong>修饰名</strong>去调用函数。<br>
那么C++是如何对函数名进行修饰的呢？来看一个例子：</p>
<pre><code>void test(int a, float b) {
	// ...
}

int main() {
	test(1, 2);
	return 0;
}
</code></pre>
<p>一段简单的代码，我们分别在 c 和 c++ 中运行，查看其汇编代码。<br>
linux 下执行以下语句来查看：</p>
<blockquote>
<p>objdump -D a.out | grep &quot;test&quot;<br>
a.out：是我生成的可执行文件名，如果不是这个名字，可修改下；<br>
grep：由于汇编代码有点长..我就写了辣么几行代码就有好多啊..干脆就通过管道找起来方便点...</p>
</blockquote>
<p>c的结果：<br>
<img src="https://user-images.githubusercontent.com/33253635/149073991-a59fc5f7-c236-4588-9e61-ce9bedb48c48.png" alt="c" loading="lazy"><br>
c++的结果：<br>
<img src="https://user-images.githubusercontent.com/33253635/149073992-e24888a6-30b4-4333-882f-3ec407456efc.png" alt="c++" loading="lazy"></p>
<p>可以看出，test 这一函数，在 c 与 c++ 汇编中的名字是不同的，c++ 对其进行的名称修饰，将原本的名字前面加了 <strong>4</strong>，表示函数名的长度为 4；test 后面加了 <strong>i</strong> 和 <strong>f</strong> ，表示第一个参数类型为 int ，第二个参数类型为 float。（当然，不同的编译器命名规则也不同）<br>
因此也就可以解释，当我们的函数名相同时，参数类型不同，或其顺序不同时，参数列表也就不同了。</p>
<p>从中也可以看出，这在 c 中是不适用的，因为其未对函数名进行修饰，所有相同名字的函数，即使参数列表不同，在汇编中的名字是相同的。<br>
所以，在<strong>链接</strong>这一阶段，便会报错，产生链接错误。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ | 引用变量]]></title>
        <id>https://ccccj.github.io/c-or-yin-yong-bian-liang/</id>
        <link href="https://ccccj.github.io/c-or-yin-yong-bian-liang/">
        </link>
        <updated>2018-03-22T09:20:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="目录">目录</h2>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E5%AF%BC%E8%AF%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F">导语：为什么要有引用变量</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5">引用的概念</a>
<ul>
<li><a href="#%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B">用法示例</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%89%B9%E5%88%AB%E4%B9%8B%E5%A4%84">引用的属性与特别之处</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8">主要作用</a>
<ul>
<li><a href="#1%E5%BC%95%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0">1.引用作参数</a>
<ul>
<li><a href="#%E7%94%A8%E6%B3%95">用法</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%A5%BD%E5%A4%84">引用传参的另一个好处</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#2%E5%BC%95%E7%94%A8%E4%BD%9C%E8%BF%94%E5%9B%9E%E5%80%BC">2.引用作返回值</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8">为何要返回引用</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98">返回引用时要注意的问题</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-2">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0">何时使用引用参数</a>
<ul>
<li><a href="#1-%E4%BC%A0%E9%80%92%E5%80%BC%E8%80%8C%E4%B8%8D%E4%BF%AE%E6%94%B9%E5%80%BC%E5%B0%BD%E9%87%8F-const-%E4%BF%AE%E9%A5%B0">1. 传递值而不修改值(尽量 const 修饰)</a></li>
<li><a href="#2-%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E5%8E%9F%E6%95%B0%E6%8D%AE">2. 需要修改原数据</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%B1%87%E7%BC%96%E5%B1%82%E6%9D%A5%E7%9C%8B">实现方法（汇编层来看）</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="导语为什么要有引用变量">导语：为什么要有引用变量</h2>
<p>拿一个简单的例子来说，要交换两个变量的值，如何交换？注意这里我们说的是，交换的功能我们会封装成一个函数。<br>
在 C 中我们都是这么调用的：</p>
<pre><code>void Swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    int a = 5;
    int b = 3;
    Swap(&amp;a, &amp;b);
    return 0;
}
</code></pre>
<p>我们采用的是一种传址的方式，而不是传值。原因在于，调用的 Swap 中的 a 、 b 是形参，而不是实参。那有没有更简便的方法？毕竟，我们这里举的只是一个简单的例子，当涉及到的东西更多时（比如之前学的单链表不带头结点删除..传二级指针简直太复杂），在 C++ 中有一个新的复合类型——引用变量。</p>
<h2 id="引用的概念">引用的概念</h2>
<p>我们说的引用变量，实际上是给另一个变量取一个<strong>别名</strong>。例如，我们已经有了一个叫做 a ，将一个新的变量 b ，作为变量 a 的引用，相当于给 a 取了一个别名叫做 b 。如下图：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMxNjE1MjkzMjI4Nj8?x-oss-process=image/format,png" alt="引用图解ab" loading="lazy"><br>
一开始我们<strong>给这块空间取了一个名字叫做 a ，后来又给他取了个小名叫做 b</strong>，相当于之后，我们对 b 进行任何操作，也会对 a 进行修改。</p>
<h3 id="用法示例">用法示例</h3>
<p>正如上面所举的例子， b 是 a 的引用变量，这就需要在创建 <strong>b</strong> 的时候，就告诉编译器这个信息，用 <strong>&amp;</strong> 来声明引用变量：</p>
<pre><code>int a;
int&amp; b = a;
</code></pre>
<p>在这里 <strong>&amp;</strong> 不是取地址操作符，而是类型标识符的一部分。正如 <strong>char</strong>* , * 也是类型标识符的一部分，表示一个指向 <strong>char</strong> 类型的指针变量，而我们的 <strong>int&amp;</strong> 表示一个指向 <strong>int</strong> 类型的引用变量。<br>
这里的 <strong>a</strong> 和 <strong>b</strong> 指向相同的值和内存单元（我的是64位平台）。可以测试一下：</p>
<pre><code>int main() {
    int a = 5;
    int&amp; b = a;
    cout &lt;&lt; &amp;a &lt;&lt; endl; // 取a的地址
    cout &lt;&lt; &amp;b &lt;&lt; endl; // 取b的地址
    return 0;
}
</code></pre>
<p>输出：</p>
<blockquote>
<p>0x7fff5fbff80c<br>
0x7fff5fbff80c</p>
</blockquote>
<p>可以看到，两个变量的地址是相同的。</p>
<pre><code>在这里， a 变量的地址是在他定义之时随机分配的，但 b 不是，他是根据自己即将要引用的变量的地址来分配。
</code></pre>
<p>既然如此，在引用变量 b 定义之时，必须初始化，而不能先声明，再赋值。也就是必须定义时就指向另一个<strong>已经定义了的变量</strong>，否则，引用变量将无法得知自己的地址，也就是说 &quot;<strong>int&amp; b;</strong>&quot; 这样的写法是错误的。</p>
<p><strong>注意：</strong><br>
当引用变量在创建时进行初始化，一旦与某个变量关联起来，就会一起效忠于他。<br>
即引用变量只能作为一个变量的引用，<strong>正如上面的 b ，当他成为 a 的引用之后，在他的生命周期里，就不能成为其他变量的引用</strong>。</p>
<p>例如，当 b 成为 a 的引用之后，如果我们试图让他成为c 的引用，并不会成功，只会实现赋值的效果(连 a 的值也相对的改变)：</p>
<pre><code>int main(int argc, const char * argv[]) {
    int a = 5;
    int&amp; b = a;

    int c = 20;
    b = c;
    cout &lt;&lt; a &lt;&lt; endl; // 输出a修改后的值
    cout &lt;&lt; b &lt;&lt; endl; // 输出b修改后的值
    return 0;
}
</code></pre>
<p>输出结果：</p>
<blockquote>
<p>20<br>
20</p>
</blockquote>
<p>总结一下上面所说的：<br>
<strong>引用变量必须在创建的时候初始化，一旦与某个变量关联起来，就只能是这个变量的引用。</strong></p>
<hr>
<p>高能预警，以下有些复杂，涉及到 临时变量、引用参数和 const ，看了好几遍 primer 上的讲解才看懂。</p>
<h3 id="引用的属性与特别之处">引用的属性与特别之处</h3>
<p>我们不能将一个变量<strong>作为右值的引用</strong>。如下：</p>
<pre><code>void test(int&amp; ra) {
    // ...
}

int main(int argc, const char * argv[]) {
    int a = 5;
    test(a + 3);
    return 0;
}
</code></pre>
<p>这样编译器将会报错。因为 a + 3 并不是变量。但是早期的编译器会比较温和的发出警告，而不是直接报错，而现在的编译器，只有参数类型为 const引用 才能编译通过。</p>
<p>这是为什么呢，接下来我们将详细剖析其中的原理。</p>
<p>以前的编译器之所以允许将表达式传给引用变量是因为，由于 a + 3 并不是 int 类型的变量，于是程序将创建一个临时的无名变量，初始化为 a + 3 的值，然后将 ra 成为该无名变量的引用。</p>
<p>那什么时候才会生成临时变量呢？有以下两种情况。</p>
<blockquote>
<p>1.实参类型正确，但不是左值<br>
2.实参类型不正确，但可以转换为正确的类型</p>
</blockquote>
<p>第一种情况：非左值会产生临时变量，哪些是非左值呢？也就是常量或包含多项的表达式。<br>
而左值就是我们可以赋值的对象。但是，在引入 const 关键字之后，<strong>常规变量</strong> 和 <strong>const 变量</strong> 都可视为左值，因为可通过地址访问他们。</p>
<blockquote>
<p>常规变量视为可修改的左值，const变量视为不可修改的左值。</p>
</blockquote>
<p>第二种情况则是类型不匹配。</p>
<p>回到之前的一个例子：</p>
<pre><code>void test(int&amp; ra) {
    ++ra;
}

int main(int argc, const char * argv[]) {
    int a = 5;
    double b = 4;
    
    test(a + 3);
    test(b);
    return 0;
}
</code></pre>
<p>上面这个例子，a + 3 作为参数属于第一种情况（不是左值）， b 属于第二种情况（类型不正确），这在以前的编译器，可以通过，是因为这时编译器产生了临时变量，分别让临时变量等于 a + 3 和 b 的值，而 ra 成为他们的引用，这对于原本的 a + 3 和 b 不并不会产生影响，所以他们的值不变。<br>
换言之，从前的编译器采取了一种机制——创建临时变量，使得原本的变量的值不会改变。因此，如果我们现在采取一种类似的机制，也能使得编译通过：使用 const 。</p>
<p>我们将代码修改为：</p>
<pre><code>void test(const int&amp; ra);
</code></pre>
<p>这样也会使得编译通过。在这样的函数中，我们的目的只是<strong>使用传递的值，而不是修改他们</strong>。后面还会具体阐述这样使用 <strong>const 与引用搭配</strong>的好处。</p>
<p>这就是为什么以前的编译器采用创建临时变量，现在采用加 const 修饰都可以编译通过的原因。</p>
<h2 id="主要作用">主要作用</h2>
<h3 id="1引用作参数">1.引用作参数</h3>
<p>引用变量的主要作用体现在函数传参。以往我们已经有了两种传参方式：按值传参、按址传参（指针）。现在有了第三种方法：按引用传参。</p>
<h4 id="用法">用法</h4>
<p>还是之前交换a、b的例子，现在有了一种新的写法：</p>
<pre><code>void Swap(int&amp; x, int&amp; y) {
    int tmp = x;
    x = y;
    y = tmp;
}

int main(int argc, const char * argv[]) {
    int a = 5;
    int b = 3;
    Swap(a, b);
    return 0;
}
</code></pre>
<p>但是有的时候，我们又不希望传入的值会改变，例如以下例子：</p>
<pre><code>int cube(int&amp; ra) {
    ra *= ra * ra;
    return ra;
}

int main() {
    int a = 3;
    int ret = cube(a);
    cout &lt;&lt; &quot;cube of &quot; &lt;&lt; a &lt;&lt; &quot; = &quot;&lt;&lt; ret &lt;&lt; endl;
    return 0;
}
</code></pre>
<blockquote>
<p>结果：cube of 27 = 27</p>
</blockquote>
<p>我们想要求 a 的立方，并且之后还要用到 a ，这时候并不希望改变 a ，而这时候 a 却被改变了。为了解决这个问题，当我们希望不改变原值时，尽量采用 <strong>const</strong> 来修饰：</p>
<pre><code>int cube(const int&amp; ra);
</code></pre>
<p>这时候我们若不小心改变了 a 的值，编译器便会报错。</p>
<p>但是我相信您肯定要问了，传参时采用引用变量作为参数的原因就是，这样可以很方便的修改原值，这时候又说不改变原值，这不是自相矛盾么？</p>
<h4 id="引用传参的另一个好处">引用传参的另一个好处</h4>
<p>这其实是因为，引用变量作为参数还有另外一个好处，便是省时间、省空间。大家都知道，我们平时传参时，都需要将原来的变量拷贝一份至一个临时变量，再将这个临时变量作为形参传入函数，但现在不需要了，因为从始至终，都是原来的那个变量。<br>
别看一个小小的原生类型占不了多少空间，复制一份也用不了多少时间，但是当我们传的是一个自定义变量，一个十分巨大的结构体或类的时候呢？，我们不需要去占用空间拷贝，这省了很多时间与空间。<br>
但同时也要注意，如果这时候您不希望改变原值，记得加上 <strong>const</strong> 来修饰。</p>
<h4 id="小结">小结</h4>
<ol>
<li>在您打算修改原变量的值时，尽量使用引用作参数，省时间省空间，更重要的是比采取指针传参的方式简单很多；</li>
<li>在您并不打算改变变量的值，但是写了一个函数，要使用到您变量的值的时候，可以采用 <strong>const + 引用</strong> 的方式，表面上看和从前两者都不用的时候效果是一样的，但实际上省了很多的时间与空间（在传参较大时）。</li>
</ol>
<h3 id="2引用作返回值">2.引用作返回值</h3>
<h4 id="为何要返回引用">为何要返回引用</h4>
<p>来看一个例子：</p>
<pre><code>double m = sqrt(16.0);
</code></pre>
<p>在这个例子中， sqrt 函数的返回值为 4.0 ，但若是让函数中的临时变量的值直接赋给 m 是不行的，因为 sqrt 函数结束，里面变量的生存周期已结束，再将其值赋给 m 可能会出错。总之，<strong>4.0 先被复制到了一个临时位置</strong>（实际上在寄存器，出了函数作用于也存在），**然后再复制给了 m **，和之前传参时情形类似。</p>
<p>不懂的可以再看下面：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMyMjE1MTk1MjI0MD8?x-oss-process=image/format,png" alt="临时变量" loading="lazy"><br>
例如上面这个程序里，c 是一个临时变量，而 Add 函数的返回值并不是 c ，因为出了这个函数， c 就相当于不在了，所以他会先将 c 的值复制给另一个临时变量（如果较小是寄存器，较大则是提前开辟好的一块空间），这个临时变量的生存周期比较长，能将其值复制给 ret 变量。</p>
<p>这样就存在一个效率问题，也就是多复制了一步。别看这里只是32位平台上八个字节的 double 变量而已，但如果是一个极大的结构体，就会浪费很多时间和空间。但是返回引用变量能很好地解决这个问题。</p>
<p>例如以下例子<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5jc2RuLm5ldC8yMDE4MDMyMjE1MjMwNjYyMD8?x-oss-process=image/format,png" alt="引用" loading="lazy"><br>
a 自增以后再返回其值，利用引用，这时候并不需要考虑生命周期的问题，因为来来回回都是在堆那一块空间进行修改，一直在 a / ra 的作用域内，省去了再复制一步的时间和空间。</p>
<h4 id="返回引用时要注意的问题">返回引用时要注意的问题</h4>
<p>引用变量作返回值并不是任何时候都那么好用的：<br>
下面是一个错误的例子：</p>
<pre><code>int&amp; Add(int a, int b) {
    int c = a + b;
    return c;
}

int main() {
    int&amp; ret = Add(1, 2);
    Add(10, 20);
    cout &lt;&lt; ret &lt;&lt; endl;
    return 0;
}
</code></pre>
<blockquote>
<p>输出结果：30</p>
</blockquote>
<p>我们之前提到了，当函数返回一个临时变量 c ，这时候会在创建一个一般在寄存器的临时变量，我们给这个变量取名为 k ，由于返回的类型是引用，这时候 k 成为了 c 的引用，而接受的类型也是引用，即 ret 是 k 的引用。当我们再调用 Add 时，k 内存放的是新的 c 的值，也就是 30，因此 ret 也跟着变为了 30 。</p>
<p>也就是说，引用作返回值，也是有前提的：<strong>引用的变量需要出了这个函数作用域还在</strong>，否则可能会出错。而前面 my_func 的例子可以用的原因是：先传入了一个引用类型的参数，再返回这个变量。从始至终，实参、形参、与返回值，都是同一个变量，这个变量一直都在。</p>
<p>同时这个时候，我们返回的是一个<strong>作为参数传递给函数的引用</strong>，正是因为如此，在这过程中这个参数可能会改变。当没有这样的参数传入的时候，我们可以开辟一块存储空间（c++ 用 new， 记得搭配 delete），在堆上就不会被自动分配与销毁了，或者返回一个静态/全局变量。</p>
<h4 id="小结-2">小结</h4>
<ol>
<li><strong>引用作返回值，不能返回一个临时变量的引用，需要变量在这个函数结束后还在，例如静态或全局变量</strong>。</li>
<li>如果可以的话，我们<strong>尽量用引用作返回值，因为更省时间和空间</strong>。</li>
</ol>
<h2 id="何时使用引用参数">何时使用引用参数</h2>
<blockquote>
<p>当然，以下只是建议，而非必须如此。</p>
</blockquote>
<h3 id="1-传递值而不修改值尽量-const-修饰">1. 传递值而不修改值(尽量 const 修饰)</h3>
<pre><code> 1、内置数据类型：由于较小，可直接按值传递；
 2、数组：采用 const 修饰的指针；
 3、较大的结构：使用 const 指针或 const 引用，可提高效率、节省时间空间；
 4、类对象：const 引用。
</code></pre>
<h3 id="2-需要修改原数据">2. 需要修改原数据</h3>
<pre><code> 1、内置数据类型：可使用指针；
 2、数组：只能使用指针；
 3、较大的结构：使用指针或引用；
 4、类对象：const 引用。
</code></pre>
<h2 id="实现方法汇编层来看">实现方法（汇编层来看）</h2>
<p>从汇编层来看，引用的最终实现方法也是借用了指针（先取了地址，再解引用）。这和我们的指针的实现机制是一样的。但从语法层面来讲，引用比指针更省空间。</p>
<p>引用与指针的区别：</p>
<ol>
<li>引用必须初始化，并且从一而终，但指针可以修改指向；</li>
<li>引用必须指向有效变量，指针可以指向空；</li>
<li>指针代表着地址，而引用代表着变量。sizeof 指针，是指针的大小，sizeof 变量，是变量的大小；</li>
<li>引用与指针自增自减的意义不同。</li>
<li>引用比指针更安全，没有野指针的危险，但同时指针也比引用灵活。</li>
</ol>
<hr>
<p>当然这肯定没把引用写完啦，但是目前就涉及了这么多，看完后面的内容再来补充啦。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ | 命名空间]]></title>
        <id>https://ccccj.github.io/c-or-ming-ming-kong-jian/</id>
        <link href="https://ccccj.github.io/c-or-ming-ming-kong-jian/">
        </link>
        <updated>2018-03-15T16:33:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>命名空间</strong>，也就是名称空间/名字空间，注意需要的头文件是 <strong>iostream</strong> ，而不是 <strong>iostream.h</strong> ，后者是旧版本的 <strong>C++</strong> 头文件，并不支持命名空间。</p>
</blockquote>
<h2 id="目录">目录：</h2>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录：</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">为什么要有命名空间？</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-std%E4%BD%BF%E7%94%A8%E5%85%A8%E9%83%A8%E4%B8%8E%E4%B8%AA%E5%88%AB">使用 std（使用全部与个别）</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E9%83%A8%E5%90%8D%E7%A7%B0">使用全部名称</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%89%80%E9%9C%80%E7%9A%84%E5%90%8D%E7%A7%B0">使用所需的名称</a></li>
</ul>
</li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%B5%8C%E5%A5%97">命名空间的嵌套</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="为什么要有命名空间">为什么要有命名空间？</h2>
<p>它的作用主要体现在，编写大型程序或将多个厂商现有的代码组合起来，他会使得更容易，更易于组织。<br>
比如说，有两个已经封装好的产品，他们呢，都有一个名叫 <strong>func()</strong> 的函数，调用这个函数的时候，编译器将不知道使用哪个函数。<br>
这时候我们可以将其划定一片区域，即将每个厂商的产品封装起来，如第一个厂商的产品放到一个叫 <strong>SUST</strong> 的名称空间中，第二个厂商的产品放到一个叫 <strong>ZJU</strong> 的名称空间中，这样便能区分开来了。</p>
<h2 id="使用方法">使用方法</h2>
<p>就像上面举出的例子，我们有了两个命名空间，那如何放入呢？<br>
如下：</p>
<pre><code>#include &lt;iostream&gt;

namespace &lt;namespace name&gt; {
    &lt;declarations&gt;
}
</code></pre>
<p>具体：</p>
<pre><code>#include &lt;iostream&gt;

namespace SUST { // 名叫 SUST 的命名空间
    void func() {
        // ...
    }
}

namespace ZJU { // 名叫 ZJU 的命名空间
    void func() {
        // ...
    }
}
</code></pre>
<p>再来看调用，需要中间加两个冒号：<br>
当使用 <strong>SUST</strong> 厂商的 <strong>func</strong> 时：</p>
<pre><code>SUST::func();
</code></pre>
<p>当使用 <strong>ZJU</strong> 厂商的 <strong>func</strong> 时：</p>
<pre><code>ZJU::func();
</code></pre>
<p>当然，不仅仅是函数，还有变量、类，都可以包括在一个命名空间中。</p>
<h2 id="使用-std使用全部与个别">使用 std（使用全部与个别）</h2>
<p>我们目前使用的大多函数，都被包括在一个标准命名空间中—— <strong>std</strong> ，例如我们知道的 <strong>cout</strong> ， <strong>cin</strong> 、还有控制符 <strong>endl</strong>等。<br>
也就是说，当我们输入输出时，并不是简单的输入输出即可，而是需要写上名称空间。如以下这句输出函数：</p>
<pre><code>std::cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; std::endl;
</code></pre>
<h3 id="使用全部名称">使用全部名称</h3>
<p>辣么问题来了，有两点，第一，我每次都要这么写，这就很麻烦了啊，第二，之前的版本（iostream.h），是没有名称空间的，现在要将之前的代码转换过来，要修改的地方就很多了。于是，一条编译指令应运而生：</p>
<pre><code>using namespace std;
</code></pre>
<p>这行代码表明，可以使用 <strong>std</strong> 名称空间中<strong>所有</strong>定义的名称，且不需要使用 <strong>std::</strong> 前缀。</p>
<h3 id="使用所需的名称">使用所需的名称</h3>
<p>当然，这会存在潜在的问题（我遇到过似乎...有时候取的变量名称会和std中的重复，我以前的编译器会报错，但是似乎现在g++更新了以后就不会了）。最好的做法是，需要什么就声明什么，例如我们要使用 <strong>cout</strong> ， <strong>cin</strong> ， <strong>endl</strong> ：</p>
<pre><code>using &lt;qualifier&gt;::&lt;name&gt;;
</code></pre>
<p>也就是：</p>
<pre><code>using std::cout;
using std::cin;
using std::endl;
</code></pre>
<p>这使得 <strong>cout</strong> ， <strong>cin</strong> ， <strong>endl</strong> 可用。</p>
<p>// 当然，之后应该会再加一些吧，因为后面第九章似乎还会讲到名称空间，目前还没看到，之后补充。</p>
<h2 id="命名空间的嵌套">命名空间的嵌套</h2>
<p>如果一个命名空间内，有两个名称相同的变量呢？要如何加以区分？这就可以使用嵌套了。<br>
如，在 <strong>SUST</strong> 这个名称空间中，有两个 <strong>func</strong> 函数，可以这么使用：</p>
<pre><code>namespace SUST {
    void func() {
        // ...
    }
    namespace test {
        void func() {
            // ...
        }
    }
}
</code></pre>
<p>调用时：</p>
<pre><code>SUST::func();
SUST::test::func();
</code></pre>
<p>（话说也不知道是不是真的有场景会用到嵌套...emmmm先写上再说）</p>
<p>以下为总的一段：</p>
<pre><code>#include &lt;iostream&gt;

using std::cout;
using std::cin;
using std::endl;

namespace SUST {
    void func() {
        cout &lt;&lt; &quot;SUST&quot; &lt;&lt; endl;
    }
    namespace test {
        void func() {
            cout &lt;&lt; &quot;test SUST&quot; &lt;&lt; endl;
        }
    }
}

namespace ZJU {
    void func() {
        cout &lt;&lt; &quot;ZJU&quot; &lt;&lt; endl;
    }
}

using namespace SUST;
using namespace ZJU;

int main(int argc, const char * argv[]) {
    SUST::func();
    SUST::test::func();
    ZJU::func();
    return 0;
}
</code></pre>
<p>运行结果：</p>
<blockquote>
<p>SUST<br>
test SUST<br>
ZJU</p>
</blockquote>
<h2 id="总结">总结</h2>
<p><strong>命名空间</strong>使得我们的变量、函数、类有了域，将他们局限在了一个域之内。在变量名/函数名重复时，可以区分他们属于哪个命名空间，加以辨别。在大型工程中应该会很好用。</p>
]]></content>
    </entry>
</feed>