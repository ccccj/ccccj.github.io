
<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<meta HTTP-EQUIV="expires" CONTENT="0"> 
<title>ACM: STL标准库容器的应用（vector、queue、list、map） | Amon&#39;s Homepage</title>	

<link rel="stylesheet" href="https://ccccj.github.io/styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

            display = "https://ccccj.github.io/media/css/night.css";

            display = "https://ccccj.github.io/media/css/night.css";   
      
            display = "https://ccccj.github.io/media/css/day.css";

            display = "https://ccccj.github.io/media/css/day.css";
      

var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://fonts.googleapis.com/css?family=Dancing+Script|Liu+Jian+Mao+Cao&display=swap" rel="stylesheet">
<link href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<script type='text/javascript' src='https://ccccj.github.io/media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>


 	
</head>
<body class="post-template-default single single-post postid-70 single-format-standard">
    <div id="wrapper">
        
			
		<header id="header" class="site-header" 
		
		>
			<div class="site-branding">
									<h1 class="site-title"><a href="https://ccccj.github.io" rel="home">Amon&#39;s Homepage</a></h1>
										
					<h2 class="site-description">温故而知新</h2>
										
							</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
		 
     			
<li>
	 
	<a  href="/"> home</a></li>
	
    
     			
<li>
	 
	<a  href="/archives"> archives</a></li>
	
    
     			
<li>
	 
	<a  href="https://github.com/ccccj"> github</a></li>
	
    
     			
<li>
	 
	<a  href="https://blog.csdn.net/qq_40873884"> CSDN</a></li>
	
    

</ul>
</li>		
		
</ul>				</div>
			</nav>
						<div class="jingge">


    

    

    

    

    

    

    

    

    

    

    

    
        </header>

		<div id="content" class="container">
			<div class="row">
	<div class="col-md-8 site-main">
				
<article id="post-70" class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">

	
	                      
		<div class="entry-content">
			<h1 class="wow swing entry-title">ACM: STL标准库容器的应用（vector、queue、list、map）</h1>
<div class="entry-meta">
<div class="wow bounce">
	<i class="iconfont icon-rili"> <time class="lately-a" datetime="2017-11-04 11:56:28" itemprop="datePublished" pubdate="">2017-11-04</time></i>
	          </div>
			
</span>
													 
		</div>
                  
			<div class="wow slideInLeft entry-summary song">
				<p>有碰到STL类型的题，就看了下关于STL的视频，粗略学习了下C++以及STL的用法...<br>
以前从没用过C++也没看过和C++相关的知识，所以很多地方还是保持的C代码的风格..很多时候scanf和printf都改不过来...<br>
但是用STL真的好方便啊...而且完全不会出错..用过以后再也不想写C了...<br>
顺便再推荐一个网站http://www.cplusplus.com/reference/<br>
查询各种函数超级超级方便。</p>
<p>四道原题，分别是vector、queue、list、map的应用。</p>
<p>https://vjudge.net/contest/208769#problem/B<br>
第一题用的vector。</p>
<p>https://vjudge.net/contest/208769#problem/E<br>
第二题用的vector和queue，本来想用list，后来感觉用queue更方便...</p>
<p>https://vjudge.net/contest/208769#problem/I<br>
第三题用的list，但是我觉得更好的方法不是用STL做...</p>
<p>https://vjudge.net/contest/208769#problem/G<br>
第四题用的map，完全不用处理...只需要输入、构造好、再输出就行了...</p>
<ul>
<li>第一题</li>
</ul>
<h4 id="the-blocks-problem">The Blocks Problem</h4>
<p>Many areas of Computer Science use simple, abstract domains for both analytical and empirical studies. For example, an early AI study of planning and robotics (STRIPS) used a block world in which a robot arm performed tasks involving the manipulation of blocks.<br>
In this problem you will model a simple block world under certain rules and constraints. Rather than determine how to achieve a speci ed state, you will “program” a robotic arm to respond to a limited set of commands.<br>
The problem is to parse a series of commands that instruct a robot arm in how to manipulate blocks that lie on a  at table. Initially there are n blocks on the table (numbered from 0 to n − 1) with block bi adjacent to block bi+1 for all 0 ≤ i &lt; n − 1 as shown in the diagram below:<br>
Initial Blocks World<br>
The valid commands for the robot arm that manipulates blocks are:<br>
• move a onto b<br>
where a and b are block numbers, puts block a onto block b after returning any blocks that are<br>
stacked on top of blocks a and b to their initial positions.<br>
• move a over b<br>
where a and b are block numbers, puts block a onto the top of the stack containing block b, after returning any blocks that are stacked on top of block a to their initial positions.<br>
• pile a onto b<br>
where a and b are block numbers, moves the pile of blocks consisting of block a, and any blocks that are stacked above block a, onto block b. All blocks on top of block b are moved to their initial positions prior to the pile taking place. The blocks stacked above block a retain their order when moved.<br>
• pile a over b<br>
where a and b are block numbers, puts the pile of blocks consisting of block a, and any blocks that are stacked above block a, onto the top of the stack containing block b. The blocks stacked above block a retain their original order when moved.<br>
• quit<br>
terminates manipulations in the block world.<br>
Any command in which a = b or in which a and b are in the same stack of blocks is an illegal command. All illegal commands should be ignored and should have no a ect on the con guration of blocks.</p>
<p>Input</p>
<p>The input begins with an integer n on a line by itself representing the number of blocks in the block world. You may assume that 0 &lt; n &lt; 25.<br>
The number of blocks is followed by a sequence of block commands, one command per line. Your program should process all commands until the quit command is encountered.<br>
You may assume that all commands will be of the form speci ed above. There will be no syntactically incorrect commands.</p>
<p>Output</p>
<p>The output should consist of the  nal state of the blocks world. Each original block position numbered i (0 ≤ i &lt; n where n is the number of blocks) should appear followed immediately by a colon. If there is at least a block on it, the colon must be followed by one space, followed by a list of blocks that appear stacked in that position with each block number separated from other block numbers by a space. Don’t put any trailing spaces on a line.<br>
There should be one line of output for each block position (i.e., n lines of output where n is the integer on the  rst line of input).</p>
<p>Sample Input</p>
<p>10<br>
move 9 onto 1<br>
move 8 over 1<br>
move 7 over 1<br>
move 6 over 1<br>
pile 8 over 6<br>
pile 8 over 5<br>
move 2 over 1<br>
move 4 over 9<br>
quit</p>
<p>Sample Output</p>
<p>0: 0<br>
1: 1 9 2 4<br>
2:<br>
3: 3<br>
4:<br>
5: 5 8 7 6<br>
6:<br>
7:<br>
8:<br>
9:</p>
<p>题目超级超级超级难读懂...看了好几遍没看懂就有道翻译了...有道看了几遍还是看不懂就百度了...主要读懂四个模拟操作就行。</p>
<ul>
<li>move onto  将a、b上的积木还原、a放到b上</li>
<li>move over  将a上的积木还原，a放到b顶端</li>
<li>pile onto  将b上积木还原，a及a上积木放到b上</li>
<li>pile over  a及a上积木放到b顶端</li>
</ul>
<p>简单讲下思路，主要是用数组，数组里面是vector（可动态增长）；<br>
主要函数有：<br>
1.查看行和高度；<br>
2.将某个块.求出高度后,上面的数还原；<br>
3.移动：移动的函数可以只有一个，若a移动到b，发现，可以统一概括为移动b的顶部；<br>
然后其他的思路什么的就很简单了...不说了不说了..</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;int&gt; pile[25]; 

void search(int &amp;row, int &amp;height, int a) // 查看第几行和高度
{
    for (int i = 0; i &lt; 25; i++) {
        for (int j = 0; j &lt; pile[i].size(); j++) {
            if (pile[i][j] == a) {
                row = i;
                height = j;
                return;
            }
        }
    }
}

void reset(int a, int row, int height) // 还原某一个块上的积木
{
    for (unsigned long i = pile[row].size() - 1; i &gt; height; i--) {
        int k = pile[row][i];
        pile[row].pop_back();
        pile[k].push_back(k);
    }
}

void block_move(int row1, int row2, int height_a) //移动a到b上，或b顶端
{
    for (int i = height_a; i &lt; pile[row1].size(); i++) {
        pile[row2].push_back(pile[row1][i]);
    }
    pile[row1].resize( height_a );
}

int main(int argc, const char * argv[]) {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for ( int i = 0; i &lt; n; i++) {
        pile[i].push_back(i);
    }
    vector&lt;int&gt; ::iterator it;
    string command1;
    string command2;
    while (cin &gt;&gt; command1 &amp;&amp; command1 != &quot;quit&quot; ) {
        int a;
        cin &gt;&gt; a;
        cin &gt;&gt; command2;
        int b;
        cin &gt;&gt; b;
        
        int row1 = 0, row2 = 0, height1 = 0, height2 = 0;
        search(row1, height1, a);
        search(row2, height2, b);
        if (row1 == row2) {
            continue;
        }
        
        if ( command1 == &quot;move&quot; ) {
            if ( command2 == &quot;onto&quot; ) {
                // move onto
                // 将a、b上的积木还原、a放到b上
                reset(a, row1, height1);
                reset(b, row2, height2);
            }
            else {
                // move over
                // 将a上的积木还原，a放到b顶端
                reset(a, row1, height1);
            }
        }
        else {
            if ( command2 == &quot;onto&quot; ) {
                // pile onto
                // 将b上积木还原，a及a上积木放到b上
                reset(b, row2, height2);
            }
            // pile over
            // a及a上积木放到b顶端
        }
        block_move(row1, row2, height1);
    }
    // 啊下面的忽略。。改不掉C
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d:&quot;,i);
        for (int j = 0; j &lt; pile[i].size(); j++) {
            printf(&quot; %d&quot;,pile[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<ul>
<li>第二题</li>
</ul>
<h4 id="team-queue">Team Queue</h4>
<p>Queues and Priority Queues are data structures which are known to most computer scientists. The Team Queue, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.<br>
In a team queue each element belongs to a team. If an element enters the queue, it  rst searches the queue from head to tail to check if some of its teammates (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.<br>
Your task is to write a program that simulates such a team queue.</p>
<p>Input</p>
<p>The input  le will contain one or more test cases. Each test case begins with the number of teams t (1 ≤ t ≤ 1000). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0..999999. A team may consist of up to 1000 elements.<br>
Finally, a list of commands follows. There are three di erent kinds of commands: • ENQUEUE x — enter element x into the team queue<br>
• DEQUEUE — process the  rst element and remove it from the queue • STOP — end of test case<br>
The input will be terminated by a value of 0 for t.<br>
Warning: A test case may contain up to 200000 (two hundred thousand) commands, so the imple- mentation of the team queue should be e cient: both enqueing and dequeuing of an element should only take constant time.</p>
<p>Output</p>
<p>For each test case,  rst print a line saying ‘Scenario #k’, where k is the number of the test case. Then, for each ‘DEQUEUE’ command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p>
<p>Sample Input</p>
<p>2<br>
3 101 102 103<br>
3 201 202 203<br>
ENQUEUE 101<br>
ENQUEUE 201<br>
ENQUEUE 102<br>
ENQUEUE 202<br>
ENQUEUE 103<br>
ENQUEUE 203<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
STOP<br>
2<br>
5 259001 259002 259003 259004 259005<br>
6 260001 260002 260003 260004 260005 260006<br>
ENQUEUE 259001<br>
ENQUEUE 260001<br>
ENQUEUE 259002<br>
ENQUEUE 259003<br>
ENQUEUE 259004<br>
ENQUEUE 259005<br>
DEQUEUE<br>
DEQUEUE<br>
ENQUEUE 260002<br>
ENQUEUE 260003<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
DEQUEUE<br>
STOP<br>
0</p>
<p>Sample Output</p>
<p>Scenario #1<br>
101<br>
102<br>
103<br>
201 202 203<br>
Scenario #2<br>
259001<br>
259002<br>
259003<br>
259004<br>
259005<br>
260001</p>
<p>这题英文还算好懂..啊现在每次读ACM的题..简直难度max的阅读理解...<br>
大概意思就是，先输入几个team，告诉你每个team的成员有谁，再输入一个入队顺序，根据前面的队员关系，判断新入队的排哪去。只要有一个队员在前面，这个队伍的其他成员就可以无限插队。<br>
所以先将每个队的队员记录下来（1.内容是vector的数组），再将每个队员（2.内容是queue的数组）的顺序记录下来，在将每个队伍的顺序记录下来（3.vector）。第一组记录完不用动，只需要不断地查找即可，第二组不断地改变，因为需要入队出队，用queue最合适（但是想了下list应该也可以），因为只要有队员在最开头，这组成员可以一直插队，但是当这组成员没有在开头了，那就不能插队，用第三组的vector来记录这一队有没有人在开头。</p>
<p>啊啊啊啊讲不清....总之不需要建立一个很长很长的队列，来看入队出队的顺序，要移动的太多了，单独每组team一个queue就可以了。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;

using namespace std;

void find_row(vector&lt;int&gt; relat[], int num, int t, int &amp;row) // 查找在哪个队
{
    for (int i = 0; i &lt; t; i++) {
        for (int j = 0; j &lt; relat[i].size(); j++) {
            if (relat[i][j] == num) {
                row = i;
                return;
            }
        }
    }
}

int judge(vector&lt;int&gt; order, int n) // 判断
{
    for (int i = 0; i &lt; order.size(); i++) {
        if (order[i] == n) {
            return 1;
        }
    }
    return 0;
}

int main()
{
    int t = 0;
    int Scenario = 0;
    while (~scanf(&quot;%d&quot;, &amp;t) &amp;&amp; t != 0) {
        
        vector&lt;int&gt; relat[1000]; // 存储关系
        queue&lt;int&gt; Queue[1000]; // 存储入队出队顺序
        vector&lt;int&gt; order; // 存储组别是否出队完
        
        int d = 0;
        for (int i = 0; i &lt; t; i++) {
            cin &gt;&gt; d;
            for (int j = 0; j &lt; d; j++) {
                int num;
                cin &gt;&gt; num;
                relat[i].push_back(num);
            }
        }
        string command;
        cin &gt;&gt; command;
        printf(&quot;Scenario #%d\n&quot;,++Scenario);
        while ( command[0] != 'S' ) {
            if (command[0] == 'E') {
                // 入队
                int num;
                cin &gt;&gt; num;
                int row = 0;
                find_row(relat, num, t, row);
                Queue[row].push(num);
                if (judge(order, row) == 0) {
                    order.push_back(row);
                }
            }
            else {
                // 出队
                int row1 = order[0];
                printf(&quot;%d\n&quot;,Queue[row1].front());
                Queue[row1].pop();
                if (Queue[row1].size() == 0) {
                    order.erase(order.begin());
                }
            }
            cin &gt;&gt; command;
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<ul>
<li>第三题</li>
</ul>
<h4 id="士兵队列训练问题">士兵队列训练问题</h4>
<p>某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。</p>
<p>Input</p>
<p>本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。</p>
<p>Output</p>
<p>共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。</p>
<p>Sample Input<br>
2<br>
20<br>
40</p>
<p>Sample Output<br>
1 7 19<br>
1 19 37</p>
<p>这道题....坑...一开始没理解题的意思，一直以为是小于等于3个人就停止，但是实际上就算小于3个人了这一轮报数也要继续下去。<br>
如果用STL做的话，最好的方法应该是双向链表list（啊不包括map啊什么的...那些我还没看过..）。对链表的访问必须要用迭代器。但是删除元素的时候要注意迭代器会指向被删除元素的下一个元素（一开始不知道，总是运行运行就访问越界了）。<br>
还有list的迭代器是双向迭代器，不是随机访问迭代器，很多操作不能做，比如说给迭代器直接+n或迭代器之间比较大小，所以有些地方的判定要注意。迭代器的每次后移，都要判定到end了没。<br>
话说end()函数，是返回一个指向头结点的迭代器（也就是最后一个结点，list是循环迭代器），所以可以用来判定。<br>
第一次的时候超时间了，因为每次判定人数都是直接用size函数，但是size需要循环，时间复杂度为O(n)，直接自己用一个计数器就不会超时了。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;

using namespace std;

int main()
{
    int N;
    while (~scanf(&quot;%d&quot;, &amp;N)) {
        while (N--) {
            list&lt;int&gt; soldier;
            int num;
            cin &gt;&gt; num;
            for (int i = 0; i &lt; num; i++) {
                soldier.push_back(i+1);
            }
            
            list&lt;int&gt;::iterator it;
            while (num &gt; 3) {
                it = soldier.begin();
                while ( it != soldier.end() ) {
                    it++;
                    if ( it == soldier.end() ) {
                        break;
                    }
                    list&lt;int&gt;::iterator it2;
                    it2 = it;
                    it2++;
                    if (it2 == soldier.end()) {
                        it = soldier.erase(it);
                        num--;
                        break;
                    } // 话说这里...好像删除最后一个结点的时候..不知道迭代器发生了什么...指不到end去了...？？？
                    it = soldier.erase(it);
                    num--;
                }
                it = soldier.begin();
                if (num &lt;= 3) {
                    break;
                }
                while (it != soldier.end() ) {
                    it++;
                    if ( it == soldier.end()) {
                        break;
                    }
                    it++;
                    if ( it == soldier.end()) {
                        break;
                    }
                    list&lt;int&gt;::iterator it2;
                    it2 = it;
                    it2++;
                    if (it2 == soldier.end()) {
                        it = soldier.erase(it);
                        num--;
                        break;
                    }
                    it = soldier.erase(it);
                    num--; 
                }
            }
            it = soldier.begin();
            cout &lt;&lt; *it;
            it++;
            for ( ; it != soldier.end(); it++) {
                cout &lt;&lt; ' ' &lt;&lt; *it ;
            }
            cout &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
<ul>
<li>第四题</li>
</ul>
<h5 id="水果">水果</h5>
<p>夏天来了~~好开心啊,呵呵,好多好多水果<br>
Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.</p>
<p>Input</p>
<p>第一行正整数N(0 &lt; N &lt;= 10)表示有N组测试数据.<br>
每组测试数据的第一行是一个整数M(0 &lt; M &lt;= 100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.</p>
<p>Output</p>
<p>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br>
两组测试数据之间有一个空行.最后一组测试数据之后没有空行.</p>
<p>Sample Input</p>
<p>1<br>
5<br>
apple shandong 3<br>
pineapple guangdong 1<br>
sugarcane guangdong 1<br>
pineapple guangdong 3<br>
pineapple guangdong 1</p>
<p>Sample Output</p>
<p>guangdong<br>
|----pineapple(5)<br>
|----sugarcane(1)<br>
shandong<br>
|----apple(3)</p>
<p>这题用map算是很合适了吧...<br>
先说下map，也是容器的一种.....<br>
好了..本来这里写了一大段，传上去以后发现，消失了！！！消失了！！难受...已经不想写了..图再发一遍吧..</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI0MjIyNjU0NTI4?x-oss-process=image/format,png" alt="这里写图片描述" loading="lazy"><br>
就简单讲下吧..这是个map &lt; string, int &gt; 容器的图，但是这道题有两个关键字，第一关键字为地区，第二关键字为水果名，所以需要两个map容器。如下图：<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMTI0MjIyOTIyODQ3?x-oss-process=image/format,png" alt=" " loading="lazy"><br>
类似于二维数组的构造（数组里面有数组），这是个map当中有map的构造，看图应该就能看懂了。一开始我一直在想，如果两个水果地区都是guangdong，那不是关键字重复了么，还查了好久关键字重复怎么办...后来画了个图就懂了，如果都是广东，在左边一列算是一个关键字，然后在右边再细分。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int N;
    string fruit, place;
    int num;
    scanf(&quot;%d&quot;, &amp;N);
    while (N--) {
        map&lt;string, map&lt;string, int&gt;&gt; myfruit;
        int M;
        cin &gt;&gt; M;
        for ( int i = 0; i &lt; M; i++) {
            cin &gt;&gt; fruit &gt;&gt; place &gt;&gt; num;
            myfruit[place][fruit] += num;
        }
        map&lt;string, map&lt;string, int&gt;&gt;::iterator it;
        map&lt;string, int&gt; :: iterator it2;
        for (it = myfruit.begin(); it != myfruit.end(); it++) {
            cout &lt;&lt; it-&gt;first &lt;&lt; endl;
            for ( it2 = it-&gt;second.begin(); it2 != it-&gt;second.end(); it2++) {
                cout &lt;&lt; &quot;   |----&quot; &lt;&lt; it2-&gt;first &lt;&lt; '(' &lt;&lt; it2-&gt;second &lt;&lt; ')' &lt;&lt; endl;
            }
        }
        if (N &gt; 0)
            cout &lt;&lt; endl;
    }
    return 0;
}

</code></pre>

							</div>
	<div class="wow bounceInDown vt-post-tags">
 
					</div>						
<nav class="navigation3 post-navigation3" role="navigation">
		
		<div class="nav-links3">
      
		<div class="wow bounceInLeft nav-previous3"><a href="https://ccccj.github.io/post/xiao-jie-or-c-yu-yan-cao-zuo-fu/" rel="prev"> 小结 | C语言操作符</a></div>
		 
		 
		<div class="wow bounceInRight nav-next3"><a href="https://ccccj.github.io/post/acmlcm-walk/" rel="next"> ACM：LCM Walk</a></div>
		
		</div>
	</nav>
	<div class="wow rollIn author-info" style="visibility: visible; animation-name: rollIn;">
	<div class="author-avatar pull-left"><img src="https://ccccj.github.io/images/avatar.png" ></div>
 
	<div class="author-description"><div class="author-title"><div class="author-link" rel="author">Amon</div></div>


		</div>
		
 
		
</article>

<div id="marlin_lite_about_widget-2" class="wow bounceInUp widget marlin_lite_about_widget" data-wow-delay="0.1s">
		
        
		<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://ccccj.github.io/media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
            av: AV, 
            el: '.comment',
            lang: 'zh-cn',
            
            admin_email:'amon1997@foxmail.com',
            
            
      emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
     	
      	
          
        });
    </script> 


   
  
 

		</div>

			</div>
			


<div class="tocc col l3 hide-on-med-and-down">
	
        <div class="toc-widget">
			
            <div class="toc-title"></div>
			
            <div id="toc-content">
			
			
			</div>
        </div>
    </div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.5.0/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>										 

 
       


			</div>
		</div>

		
		 	<footer id="colophon" class="site-footer">

			<div class="container">
	
				<div class="copyright">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a><br>Theme:   <a href="https://github.com/shanbufun/gridea-theme-pan" target="_blank" title="Pan"><span>Pan</span></a>.  by <a href="https://shanbu.fun/" target="_blank"  title="山卜方" >Shanbufun</a></div>		
			</div>
		
		</footer>

</div>

<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://ccccj.github.io/media/scripts/marlin-scripts.js'></script>
 <script src="//tokinx.github.io/lately/lately.min.js"></script>
  <script>jQuery(document).ready(function(){$.lately({'target':'.lately-a,.lately-b,.lately-c'})});</script>
  <style type="text/css">a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
}

a.back_to_top span {
    color: #888;
}

a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
}

a.back_to_top:hover span {
    color: #555;
}

@media print, screen and (max-width: 580px) {
    .back_to_top {
        display: none !important;
    }
}



</style><a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>


<script>$(document).ready((function(_this) {
  return function() {
    var bt;
    bt = $('#back_to_top');
    if ($(document).width() > 480) {
      $(window).scroll(function() {
        var st;
        st = $(window).scrollTop();
        if (st > 30) {
          return bt.css('display', 'block');
        } else {
          return bt.css('display', 'none');
        }
      });
      return bt.click(function() {
        $('body,html').animate({
          scrollTop: 0
        }, 800);
        return false;
      });
    }
  };
})(this));
</script>

		<script data-no-instant>
    (function ($) {
        $.extend({
            adamsOverload: function () {
                $('.navigation:eq(0)').remove();
                $("").attr("rel" , "external");
                $("a[rel='external'],a[rel='external nofollow']").attr("target","_blank");
                $("a.vi").attr("rel" , "");
                $.viewImage({
                    'target'  : 'img',
                    'exclude' : '.vsmile-icons img,.gallery img',
                    'delay'   : 300
                });
                $.lately({
                    'target' : '.commentmetadata a,.infos time,.post-list time'
                });
                prettyPrint();
                
                $('ul.links li a').each(function(){
                    if($(this).parent().find('.bg').length==0){
                        $(this).parent().append('<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain='+$(this).attr("href")+')"></div>--->')
                    }
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>

</body>
</html>
